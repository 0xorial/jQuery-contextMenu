<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes_ContextMenu.js.html":{"id":"classes_ContextMenu.js.html","title":"Source: classes/ContextMenu.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: classes/ContextMenu.js import ContextMenuOperations from './ContextMenuOperations'; import defaults from '../defaults'; import ContextMenuHtml5Builder from './ContextMenuHtml5Builder'; import ContextMenuEventHandler from './ContextMenuEventHandler'; export default class ContextMenu { /** * @constructor * @constructs ContextMenu * @classdesc The ContextMenu is the core class that manages contextmenu's. You can call this class directly and skip going through jQuery. * @class ContextMenu * * @example * // You can call this class directly and skip going through jQuery, although it still requires jQuery to run. * const manager = new ContextMenu(); * manager.execute(&quot;create&quot;, options); * * @property {ContextMenuSettings|Object} defaults * @property {ContextMenuEventHandler} handle * @property {ContextMenuOperations} operations * @property {Object&lt;string, ContextMenuData&gt;} menus * @property {number} counter - Internal counter to keep track of different menu's on the page. * @property {boolean} initialized - Flag the menu as initialized. */ constructor() { this.html5builder = new ContextMenuHtml5Builder(); this.defaults = defaults; this.handler = new ContextMenuEventHandler(); this.operations = new ContextMenuOperations(); this.namespaces = {}; this.initialized = false; this.menus = {}; this.counter = 0; } /** * @method execute * @memberOf ContextMenu * @instance * * @param {(string|ContextMenuSettings)} operation * @param {(string|ContextMenuSettings)} options * @return {ContextMenu} */ execute(operation, options) { const normalizedArguments = this.normalizeArguments(operation, options); operation = normalizedArguments.operation; options = normalizedArguments.options; // merge with default options const o = $.extend(true, {manager: this}, this.defaults, options || {}); const $document = $(document); let $context = $document; let _hasContext = false; if (!o.context || !o.context.length) { o.context = document; } else { // you never know what they throw at you... $context = $(o.context).first(); o.context = $context.get(0); _hasContext = !$(o.context).is($(document)); } switch (operation) { case 'update': // Updates visibility and such if (_hasContext) { this.operations.update(null, $context); } else { for (let menu in this.menus) { if (this.menus.hasOwnProperty(menu)) { this.operations.update(null, this.menus[menu]); } } } break; case 'create': // no selector no joy if (!o.selector) { throw new Error('No selector specified'); } // make sure internal classes are not bound to if (o.selector.match(/.context-menu-(list|item|input)($|\\s)/)) { throw new Error('Cannot bind to selector &quot;' + o.selector + '&quot; as it contains a reserved className'); } if (!o.build &amp;&amp; (!o.items || $.isEmptyObject(o.items))) { throw new Error('No Items specified'); } this.counter++; o.ns = '.contextMenu' + this.counter; if (!_hasContext) { this.namespaces[o.selector] = o.ns; } this.menus[o.ns] = o; // default to right click if (!o.trigger) { o.trigger = 'right'; } if (!this.initialized) { const itemClick = o.itemClickEvent === 'click' ? 'click.contextMenu' : 'mouseup.contextMenu'; const contextMenuItemObj = { // 'mouseup.contextMenu': this.handler.itemClick, // 'click.contextMenu': this.handler.itemClick, 'contextmenu:focus.contextMenu': this.handler.focusItem, 'contextmenu:blur.contextMenu': this.handler.blurItem, 'contextmenu.contextMenu': this.handler.abortevent, 'mouseenter.contextMenu': this.handler.itemMouseenter, 'mouseleave.contextMenu': this.handler.itemMouseleave }; contextMenuItemObj[itemClick] = this.handler.itemClick; // make sure item click is registered first $document .on({ 'contextmenu:hide.contextMenu': this.handler.hideMenu, 'prevcommand.contextMenu': this.handler.prevItem, 'nextcommand.contextMenu': this.handler.nextItem, 'contextmenu.contextMenu': this.handler.abortevent, 'mouseenter.contextMenu': this.handler.menuMouseenter, 'mouseleave.contextMenu': this.handler.menuMouseleave }, '.context-menu-list') .on('mouseup.contextMenu', '.context-menu-input', this.handler.inputClick) .on(contextMenuItemObj, '.context-menu-item'); this.initialized = true; } // engage native contextmenu event $context .on('contextmenu' + o.ns, o.selector, o, this.handler.contextmenu); if (_hasContext) { // add remove hook, just in case $context.on('remove' + o.ns, function () { $(this).contextMenu('destroy'); }); } switch (o.trigger) { case 'hover': $context .on('mouseenter' + o.ns, o.selector, o, this.handler.mouseenter) .on('mouseleave' + o.ns, o.selector, o, this.handler.mouseleave); break; case 'left': $context.on('click' + o.ns, o.selector, o, this.handler.click); break; case 'touchstart': $context.on('touchstart' + o.ns, o.selector, o, this.handler.click); break; /* default: // http://www.quirksmode.org/dom/events/contextmenu.html $document .on('mousedown' + o.ns, o.selector, o, this.handler.mousedown) .on('mouseup' + o.ns, o.selector, o, this.handler.mouseup); break; */ } // create menu if (!o.build) { this.operations.create(null, o); } break; case 'destroy': let $visibleMenu; if (_hasContext) { // get proper options const context = o.context; Object.keys(this.menus).forEach((ns) =&gt; { let o = this.menus[ns]; if (!o) { return true; } // Is this menu equest to the context called from if (!$(context).is(o.selector)) { return true; } $visibleMenu = $('.context-menu-list').filter(':visible'); if ($visibleMenu.length &amp;&amp; $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) { $visibleMenu.trigger('contextmenu:hide', {force: true}); } if (this.menus[o.ns].$menu) { this.menus[o.ns].$menu.remove(); } delete this.menus[o.ns]; $(o.context).off(o.ns); return true; }); } else if (!o.selector) { $document.off('.contextMenu .contextMenuAutoHide'); Object.keys(this.menus).forEach((ns) =&gt; { let o = this.menus[ns]; $(o.context).off(o.ns); }); this.namespaces = {}; this.menus = {}; this.counter = 0; this.initialized = false; $('#context-menu-layer, .context-menu-list').remove(); } else if (this.namespaces[o.selector]) { $visibleMenu = $('.context-menu-list').filter(':visible'); if ($visibleMenu.length &amp;&amp; $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) { $visibleMenu.trigger('contextmenu:hide', {force: true}); } if (this.menus[this.namespaces[o.selector]].$menu) { this.menus[this.namespaces[o.selector]].$menu.remove(); } delete this.menus[this.namespaces[o.selector]]; $document.off(this.namespaces[o.selector]); } break; case 'html5': // if &lt;command&gt; and &lt;menuitem&gt; are not handled by the browser, // or options was a bool true, // initialize $.contextMenu for them if ((!$.support.htmlCommand &amp;&amp; !$.support.htmlMenuitem) || (typeof options === 'boolean' &amp;&amp; options)) { $('menu[type=&quot;context&quot;]').each(function () { if (this.id) { $.contextMenu({ selector: '[contextmenu=' + this.id + ']', items: $.contextMenu.fromMenu(this) }); } }).css('display', 'none'); } break; default: throw new Error('Unknown operation &quot;' + operation + '&quot;'); } return this; } normalizeArguments(operation, options) { if (typeof operation !== 'string') { options = operation; operation = 'create'; } if (typeof options === 'string') { options = {selector: options}; } else if (typeof options === 'undefined') { options = {}; } return {operation, options}; } /** * import values into `&lt;input&gt;` commands * * @method setInputValues * @memberOf ContextMenu * @instance * * @param {ContextMenuData} opt - {@link ContextMenuData} object * @param {Object} data - Values to set * @return {undefined} */ setInputValues(opt, data) { if (typeof data === 'undefined') { data = {}; } $.each(opt.inputs, function (key, item) { switch (item.type) { case 'text': case 'textarea': item.value = data[key] || ''; break; case 'checkbox': item.selected = !!data[key]; break; case 'radio': item.selected = (data[item.radio] || '') === item.value; break; case 'select': item.selected = data[key] || ''; break; } }); } /** * export values from `&lt;input&gt;` commands * * @method getInputValues * @memberOf ContextMenu * @instance * * @param {ContextMenuData} opt - {@link ContextMenuData} object * @param {Object} data - Values object * @return {Object} - Values of input elements */ getInputValues(opt, data) { if (typeof data === 'undefined') { data = {}; } $.each(opt.inputs, function (key, item) { switch (item.type) { case 'text': case 'textarea': case 'select': data[key] = item.$input.val(); break; case 'checkbox': data[key] = item.$input.prop('checked'); break; case 'radio': if (item.$input.prop('checked')) { data[item.radio] = item.value; } break; } }); return data; } } × Search results Close "},"defaults_interfaces.js.html":{"id":"defaults_interfaces.js.html","title":"Source: defaults/interfaces.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: defaults/interfaces.js /** * Specifies the icon class to set for the item. * * When using a string icons must be defined in CSS with selectors like `.context-menu-item.context-menu-icon-edit`, where edit is the icon class specified. * * When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. * * @example * var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, opt, root){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + opt.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } * * @callback ContextMenuIconCallback * @param {ContextMenuEvent|JQuery.Event} e, * @param {JQuery} $t * @param {string} key * @param {ContextMenuItem} item * @param {ContextMenuData} opt * @param {ContextMenuData} root */ /** * Specifies the icon class to set for the item. * * When using a string icons must be defined in CSS with selectors like `.context-menu-item.context-menu-icon-edit`, where edit is the icon class specified. * * When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. * * @example * var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, opt, root){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + opt.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } * * @callback ContextMenuIconCallback * @param {ContextMenuEvent|JQuery.Event} e, * @param {JQuery} $t * @param {string} key * @param {ContextMenuItem} item * @param {ContextMenuData} opt * @param {ContextMenuData} root */ /** * The Callback is executed in the context of the triggering object. * * @callback ContextMenuItemCallback * @param {JQuery.Event} e - Event that trigged the menu. * @param {string} key - Key of the menu item. * @param {ContextMenuData} opt - Data of the (sub)menu in which the item resides. * @param {ContextMenuData} root - Data of the root menu in which the item resides. Might be the same as `opt` if triggered in the menu root. * @return {boolean} */ /** * @callback ContextMenuBuildCallback * @param {JQuery.Event} e - Event that trigged the menu. * @param {JQuery} $currentTrigger - Element that trigged the menu. * @return {Object.&lt;string,ContextMenuItem&gt;} */ × Search results Close "},"defaults_index.js.html":{"id":"defaults_index.js.html","title":"Source: defaults/index.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: defaults/index.js import {determinePosition, positionSubmenu, position} from './position'; /** * @class ContextMenuData * @augments ContextMenuSettings * @instance * @interface * * @property {JQuery} $menu - The menu element for this menu part. Eg. the root menu, or a single submenu. * @property {JQuery} $layer - The opened layer when the menu is opened. * @property {JQuery} $node - The menu node. * @property {JQuery} $trigger - The element that triggered opening the menu. * @property {JQuery} $selected - Reference to the `&lt;li&gt;` command element. * @property {JQuery} $input - Reference to the `&lt;input&gt;` or `&lt;select&gt;` of the command element. * @property {JQuery} $label - Reference to the `&lt;input&gt;` or `&lt;select&gt;` of the command element. * @property {string} ns - The namespace (including leading dot) all events for this contextMenu instance were registered under. * @property {ContextMenu} manager - The contextmenu manager instance. * @property {JQuery|jQuery|null} $selected - Currently selected menu item, or input inside menu item. * @property {?boolean} hasTypes - The menu has ContextMenuItem which are of a selectable type. * @property {?boolean} isInput - We are currently originating events from an input. * @property {Object&lt;string, ContextMenuItem&gt;} inputs - Inputs defined in the menu. * * @property {boolean} hovering Currently hovering, root menu only. */ /** * @class ContextMenuSettings * @instance * @interface * @classdesc ## Register new contextMenu To register a new contextMenu: ```javascript $.contextMenu( contextMenuOptions ); ``` ## Update contextMenu state It is possible to refresh the state of the contextmenu [disabled](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#disabled), [visibility](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#visible), [icons](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#icon) and [input values](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#type) through the `update` command. This will reevaluate any custom callbacks. ```javascript $('.context-menu-one').contextMenu('update'); // update single menu $.contextMenu('update') // update all open menus ``` * @property {null|string} selector - Selector on which the contextMenu triggers. * @property {Object.&lt;string, ContextMenuItem&gt;} items - Object with items to be listed in contextMenu. See {@link ContextMenuItem} for a full documentation on how to build your menu items. * @property {JQuery.Selector|DOMElement} [appendTo=document.body] - Specifies the selector `string` or `DOMElement` the generated menu is to be appended to. * @property {('right'|'left'|'hover'|'touchstart'|'none')} trigger=left - Method to trigger context menu [&quot;right&quot;, &quot;left&quot;, &quot;hover&quot;, &quot;touchstart&quot;, &quot;none&quot;]. * @property {?string} itemClickEvent - Allows the selection of the click event instead of the mouseup event to handle the user mouse interaction with the contexMenu. The default event is `mouseup`. Set the option to `&quot;click&quot;` to change to the `click` event. This option is global: the first contexMenu registered sets it. To change it afterwards all the contextMenu have to be unregistered with `$.contextMenu( 'destroy' );` before the change has effect again. * @property {boolean} hideOnSecondTrigger=false - Flag denoting if a second trigger should close the menu, as long as the trigger happened on one of the trigger-element's child nodes. This overrides the reposition option. * @property {boolean} selectableSubMenu=false - Ability to select ContextMenuItem containing a submenu. * @property {boolean} reposition=true - flag denoting if a second trigger should simply move (`true`) or rebuild (`false`) an open menu as long as the trigger happened on one of the trigger-element's child nodes * @property {number} delay=200 - ms to wait before showing a hover-triggered context menu. * @property {boolean} autoHide=true - Hide menu when mouse leaves trigger / menu elements. * @property {number|Function} zIndex=1 - offset to add to zIndex * @property {string} className - Class to be appended to the root menu. * @property {Object} classNames - Default classname configuration to be able avoid conflicts in frameworks. * @property {string} classNames.hover=context-menu-hover * @property {string} classNames.disabled=context-menu-disabled * @property {string} classNames.visible=context-menu-visible * @property {string} classNames.notSelectable=context-menu-not-selectable * @property {string} classNames.icon=context-menu-icon * @property {string} classNames.iconEdit=context-menu-icon-edit * @property {string} classNames.iconCut=context-menu-icon-cut * @property {string} classNames.iconCopy=context-menu-icon-copy * @property {string} classNames.iconPaste=context-menu-icon-paste * @property {string} classNames.iconDelete=context-menu-icon-delete * @property {string} classNames.iconAdd=context-menu-icon-add * @property {string} classNames.iconQuit=context-menu-icon-quit * @property {string} classNames.iconLoadingClass=context-menu-icon-loading * @property {Object} animation - Animation settings * @property {number} animation.duration=50 * @property {string} animation.show='slideDown' * @property {string} animation.hide='slideUp' * @property {Object} events - Event callbacks. This is the trigger element, first argument is the event, and the second argumant {@link ContextMenuData}. * @property {Function} events.show - Called when contextmenu is shown. * @property {Function} events.hide - Called when contextmenu is hidden. * @property {Function} events.activated - Called when contextmenu is activated. * @property {ContextMenuItemCallback} callback - Global callback called then a {@link ContextMenuItem} is clicked. * @property {ContextMenuBuildCallback} build=false * @property {(position)} position - Callback to override the position of the context menu. The function is executed in the context of the trigger object. The first argument is a jQuery.Event. The second argument is the {@link ContextMenuData} object, which has a `$menu` property with the menu that needs to be positioned. The third and fourth arguments are `x` and `y` coordinates provided by the show event. The `x` and `y` may either be integers denoting the offset from the top left corner, undefined, or the string &quot;maintain&quot;. If the string &quot;maintain&quot; is provided, the current position of the `$menu` must be used. If the coordinates are `undefined`, appropriate coordinates must be determined. An example of how this can be achieved is provided with {@link determinePosition}. * @property {(determinePosition)} determinePosition * @property {(positionSubmenu)} positionSubmenu - Callback tha positions a submenu */ export default { selector: null, // where to append the menu to appendTo: null, // method to trigger context menu [&quot;right&quot;, &quot;left&quot;, &quot;hover&quot;] trigger: 'right', // hide menu when mouse leaves trigger / menu elements autoHide: false, // ms to wait before showing a hover-triggered context menu delay: 200, // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu // as long as the trigger happened on one of the trigger-element's child nodes reposition: true, // Flag denoting if a second trigger should close the menu, as long as // the trigger happened on one of the trigger-element's child nodes. // This overrides the reposition option. hideOnSecondTrigger: false, // ability to select submenu selectableSubMenu: false, className: '', // Default classname configuration to be able avoid conflicts in frameworks classNames: { hover: 'context-menu-hover', // Item hover disabled: 'context-menu-disabled', // Item disabled visible: 'context-menu-visible', // Item visible notSelectable: 'context-menu-not-selectable', // Item not selectable icon: 'context-menu-icon', iconEdit: 'context-menu-icon-edit', iconCut: 'context-menu-icon-cut', iconCopy: 'context-menu-icon-copy', iconPaste: 'context-menu-icon-paste', iconDelete: 'context-menu-icon-delete', iconAdd: 'context-menu-icon-add', iconQuit: 'context-menu-icon-quit', iconLoadingClass: 'context-menu-icon-loading' }, // offset to add to zIndex zIndex: 1, // show hide animation settings animation: { duration: 50, show: 'slideDown', hide: 'slideUp' }, // events events: { show: $.noop, hide: $.noop, activated: $.noop }, // default callback callback: null, // list of contextMenu items items: {}, // Build callback for creating a menu dynamicly build: false, types: {}, // determine position to show menu at determinePosition, // position menu position, // position the sub-menu positionSubmenu }; × Search results Close "},"defaults_position.js.html":{"id":"defaults_position.js.html","title":"Source: defaults/position.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: defaults/position.js /** * Determine the position for a root menu. * @memberOf ContextMenuSettings * @function ContextMenuSettings#determinePosition * @param {(JQuery)} $menu */ export function determinePosition($menu) { // position to the lower middle of the trigger element if ($.ui &amp;&amp; $.ui.position) { // .position() is provided as a jQuery UI utility // (...and it won't work on hidden elements) $menu.css('display', 'block').position({ my: 'center top', at: 'center bottom', of: this, offset: '0 5', collision: 'fit' }).css('display', 'none'); } else { // determine contextMenu position const offset = this.offset(); offset.top += this.outerHeight(); offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2; $menu.css(offset); } } /** * Position the root menu. * @memberOf ContextMenuSettings * @function ContextMenuSettings#position * @param {JQuery.Event} e * @param {ContextMenuData} opt * @param {(number|string)} x * @param {(number|string)} y */ export function position(e, opt, x, y) { const $window = $(window); let offset; // determine contextMenu position if (!x &amp;&amp; !y) { opt.determinePosition.call(this, opt.$menu); return; } else if (x === 'maintain' &amp;&amp; y === 'maintain') { // x and y must not be changed (after re-show on command click) offset = opt.$menu.position(); } else { // x and y are given (by mouse event) const offsetParentOffset = opt.$menu.offsetParent().offset(); offset = {top: y - offsetParentOffset.top, left: x - offsetParentOffset.left}; } // correct offset if viewport demands it const bottom = $window.scrollTop() + $window.height(); const right = $window.scrollLeft() + $window.width(); const height = opt.$menu.outerHeight(); const width = opt.$menu.outerWidth(); if (offset.top + height &gt; bottom) { offset.top -= height; } if (offset.top &lt; 0) { offset.top = 0; } if (offset.left + width &gt; right) { offset.left -= width; } if (offset.left &lt; 0) { offset.left = 0; } opt.$menu.css(offset); } /** * Position a submenu. * @memberOf ContextMenuSettings * @function ContextMenuSettings#positionSubmenu * @param {JQuery.Event} e * @param {JQuery} $menu */ // position the sub-menu export function positionSubmenu(e, $menu) { if (typeof $menu === 'undefined') { // When user hovers over item (which has sub items) handle.focusItem will call this. // but the submenu does not exist yet if opt.items is a promise. just return, will // call positionSubmenu after promise is completed. return; } if ($.ui &amp;&amp; $.ui.position) { // .position() is provided as a jQuery UI utility // (...and it won't work on hidden elements) $menu.css('display', 'block').position({ my: 'left top-5', at: 'right top', of: this, collision: 'flipfit fit' }).css('display', ''); } else { // determine contextMenu position const offset = { top: -9, left: this.outerWidth() - 5 }; $menu.css(offset); } } × Search results Close "},"classes_ContextMenuEventHandler.js.html":{"id":"classes_ContextMenuEventHandler.js.html","title":"Source: classes/ContextMenuEventHandler.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: classes/ContextMenuEventHandler.js import defaults from '../defaults'; /** * @typedef {jQuery.Event} ContextMenuEvent * @augments jQuery.Event * @property {ContextMenuData} data */ export default class ContextMenuEventHandler { /** * @constructs ContextMenuEventHandler * @constructor * @property {?JQuery} $currentTrigger * @property {Object} hoveract */ constructor() { this.$currentTrigger = null; this.hoveract = {}; } /** * Helper to abort an event * * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ abortevent(e) { e.preventDefault(); e.stopImmediatePropagation(); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ contextmenu(e) { const $this = $(e.currentTarget); if (!e.data) { throw new Error('No data attached'); } // disable actual context-menu if we are using the right mouse button as the trigger if (e.data.trigger === 'right') { e.preventDefault(); e.stopImmediatePropagation(); } // abort native-triggered events unless we're triggering on right click if ((e.data.trigger !== 'right' &amp;&amp; e.data.trigger !== 'demand') &amp;&amp; e.originalEvent) { return; } // Let the current contextmenu decide if it should show or not based on its own trigger settings if (typeof e.mouseButton !== 'undefined') { if (!(e.data.trigger === 'left' &amp;&amp; e.mouseButton === 0) &amp;&amp; !(e.data.trigger === 'right' &amp;&amp; e.mouseButton === 2)) { // Mouse click is not valid. return; } } // abort event if menu is visible for this trigger if ($this.hasClass('context-menu-active')) { return; } if (!$this.hasClass('context-menu-disabled')) { // theoretically need to fire a show event at &lt;menu&gt; // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus // var evt = jQuery.Event(&quot;show&quot;, { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this }); // e.data.$menu.trigger(evt); e.data.manager.handler.$currentTrigger = $this; if (e.data.build) { const built = e.data.build(e, $this); // abort if build() returned false if (built === false) { return; } // dynamically build menu on invocation e.data = $.extend(true, {}, defaults, e.data, built || {}); // abort if there are no items to display if (!e.data.items || $.isEmptyObject(e.data.items)) { // Note: jQuery captures and ignores errors from event handlers if (window.console) { (console.error || console.log).call(console, 'No items specified to show in contextMenu'); } throw new Error('No Items specified'); } // backreference for custom command type creation e.data.$trigger = e.data.manager.handler.$currentTrigger; e.data.manager.operations.create(e, e.data); } let showMenu = false; for (let item in e.data.items) { if (e.data.items.hasOwnProperty(item)) { let visible; if ($.isFunction(e.data.items[item].visible)) { visible = e.data.items[item].visible.call($this, e, item, e.data, e.data); } else if (typeof e.data.items[item] !== 'undefined' &amp;&amp; e.data.items[item].visible) { visible = e.data.items[item].visible === true; } else { visible = true; } if (visible) { showMenu = true; } } } if (showMenu) { // show menu e.data.manager.operations.show.call($this, e, e.data, e.pageX, e.pageY); } } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ click(e) { e.preventDefault(); e.stopImmediatePropagation(); $(this).trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY, originalEvent: e})); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mousedown(e) { // register mouse down const $this = $(this); // hide any previous menus if (e.data.manager.handler.$currentTrigger &amp;&amp; e.data.manager.handler.$currentTrigger.length &amp;&amp; !e.data.manager.handler.$currentTrigger.is($this)) { e.data.manager.handler.$currentTrigger.data('contextMenu').$menu.trigger($.Event('contextmenu', {originalEvent: e})); } // activate on right click if (e.button === 2) { e.data.manager.handler.$currentTrigger = $this.data('contextMenuActive', true); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mouseup(e) { // show menu const $this = $(this); if ($this.data('contextMenuActive') &amp;&amp; e.data.manager.handler.$currentTrigger &amp;&amp; e.data.manager.handler.$currentTrigger.length &amp;&amp; e.data.manager.handler.$currentTrigger.is($this) &amp;&amp; !$this.hasClass('context-menu-disabled')) { e.preventDefault(); e.stopImmediatePropagation(); e.data.manager.handler.$currentTrigger = $this; $this.trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY, originalEvent: e})); } $this.removeData('contextMenuActive'); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mouseenter(e) { const $this = $(this); const $related = $(e.relatedTarget); const $document = $(document); // abort if we're coming from a menu if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) { return; } // abort if a menu is shown if (e.data.manager.handler.$currentTrigger &amp;&amp; e.data.manager.handler.$currentTrigger.length) { return; } e.data.manager.handler.hoveract.pageX = e.pageX; e.data.manager.handler.hoveract.pageY = e.pageY; e.data.manager.handler.hoveract.data = e.data; $document.on('mousemove.contextMenuShow', e.data.manager.handler.mousemove); e.data.manager.handler.hoveract.timer = setTimeout(function () { e.data.manager.handler.hoveract.timer = null; $document.off('mousemove.contextMenuShow'); e.data.manager.handler.$currentTrigger = $this; $this.trigger($.Event('contextmenu', { data: e.data.manager.handler.hoveract.data, pageX: e.data.manager.handler.hoveract.pageX, pageY: e.data.manager.handler.hoveract.pageY })); }, e.data.delay); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mousemove(e) { e.data.manager.handler.hoveract.pageX = e.pageX; e.data.manager.handler.hoveract.pageY = e.pageY; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mouseleave(e) { // abort if we're leaving for a menu const $related = $(e.relatedTarget); if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) { return; } try { clearTimeout(e.data.manager.handler.hoveract.timer); } catch (e) { } e.data.manager.handler.hoveract.timer = null; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ layerClick(e) { let $this = $(this); let root = $this.data('contextMenuRoot'); if (root === null || typeof root === 'undefined') { throw new Error('No ContextMenuData found'); } let button = e.button; let x = e.pageX; let y = e.pageY; let target; let offset; e.preventDefault(); setTimeout(function () { let $window = $(window); let triggerAction = ((root.trigger === 'left' &amp;&amp; button === 0) || (root.trigger === 'right' &amp;&amp; button === 2)); // find the element that would've been clicked, wasn't the layer in the way if (document.elementFromPoint &amp;&amp; root.$layer) { root.$layer.hide(); target = document.elementFromPoint(x - $window.scrollLeft(), y - $window.scrollTop()); // also need to try and focus this element if we're in a contenteditable area, // as the layer will prevent the browser mouse action we want if (target.isContentEditable) { const range = document.createRange(); const sel = window.getSelection(); range.selectNode(target); range.collapse(true); sel.removeAllRanges(); sel.addRange(range); } $(target).trigger(e); root.$layer.show(); } if (root.hideOnSecondTrigger &amp;&amp; triggerAction &amp;&amp; root.$menu !== null &amp;&amp; typeof root.$menu !== 'undefined') { root.$menu.trigger('contextmenu:hide', {originalEvent: e}); return; } if (root.reposition &amp;&amp; triggerAction) { if (document.elementFromPoint) { if (root.$trigger.is(target)) { root.position.call(root.$trigger, e, root, x, y); return; } } else { offset = root.$trigger.offset(); const $window = $(window); // while this looks kinda awful, it's the best way to avoid // unnecessarily calculating any positions offset.top += $window.scrollTop(); if (offset.top &lt;= e.pageY) { offset.left += $window.scrollLeft(); if (offset.left &lt;= e.pageX) { offset.bottom = offset.top + root.$trigger.outerHeight(); if (offset.bottom &gt;= e.pageY) { offset.right = offset.left + root.$trigger.outerWidth(); if (offset.right &gt;= e.pageX) { // reposition root.position.call(root.$trigger, e, root, x, y); return; } } } } } } if (target &amp;&amp; triggerAction) { root.$trigger.one('contextmenu:hidden', function () { $(target).contextMenu({x: x, y: y, button: button, originalEvent: e}); }); } if (root.$menu !== null &amp;&amp; typeof root.$menu !== 'undefined') { root.$menu.trigger('contextmenu:hide', {originalEvent: e}); } }, 50); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e * @param {ContextMenuItem} opt */ keyStop(e, opt) { if (!opt.isInput) { e.preventDefault(); } e.stopPropagation(); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ key(e) { let opt = {}; // Only get the data from this.$currentTrigger if it exists if (e.data.manager.handler.$currentTrigger) { opt = e.data.manager.handler.$currentTrigger.data('contextMenu') || {}; } // If the trigger happen on a element that are above the contextmenu do this if (typeof opt.zIndex === 'undefined') { opt.zIndex = 0; } const getZIndexOfTriggerTarget = function (target) { if (target.style.zIndex !== '') { return target.style.zIndex; } else { if (target.offsetParent !== null &amp;&amp; typeof target.offsetParent !== 'undefined') { return getZIndexOfTriggerTarget(target.offsetParent); } else if (target.parentElement !== null &amp;&amp; typeof target.parentElement !== 'undefined') { return getZIndexOfTriggerTarget(target.parentElement); } } }; let targetZIndex = getZIndexOfTriggerTarget(e.target); // If targetZIndex is heigher then opt.zIndex dont progress any futher. // This is used to make sure that if you are using a dialog with a input / textarea / contenteditable div // and its above the contextmenu it wont steal keys events if (opt.$menu &amp;&amp; parseInt(targetZIndex, 10) &gt; parseInt(opt.$menu.css('zIndex'), 10)) { return; } switch (e.keyCode) { case 9: case 38: // up e.data.manager.handler.keyStop(e, opt); // if keyCode is [38 (up)] or [9 (tab) with shift] if (opt.isInput) { if (e.keyCode === 9 &amp;&amp; e.shiftKey) { e.preventDefault(); if (opt.$selected) { opt.$selected.find('input, textarea, select').blur(); } if (opt.$menu !== null &amp;&amp; typeof opt.$menu !== 'undefined') { opt.$menu.trigger('prevcommand', {originalEvent: e}); } return; } else if (e.keyCode === 38 &amp;&amp; opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') { // checkboxes don't capture this key e.preventDefault(); return; } } else if (e.keyCode !== 9 || e.shiftKey) { if (opt.$menu !== null &amp;&amp; typeof opt.$menu !== 'undefined') { opt.$menu.trigger('prevcommand', {originalEvent: e}); } return; } break; // omitting break; // case 9: // tab - reached through omitted break; case 40: // down e.data.manager.handler.keyStop(e, opt); if (opt.isInput) { if (e.keyCode === 9) { e.preventDefault(); if (opt.$selected) { opt.$selected.find('input, textarea, select').blur(); } if (opt.$menu !== null &amp;&amp; typeof opt.$menu !== 'undefined') { opt.$menu.trigger('nextcommand', {originalEvent: e}); } return; } else if (e.keyCode === 40 &amp;&amp; opt.$selected.find('input, textarea, select').prop('type') === 'checkbox') { // checkboxes don't capture this key e.preventDefault(); return; } } else { if (opt.$menu !== null &amp;&amp; typeof opt.$menu !== 'undefined') { opt.$menu.trigger('nextcommand', {originalEvent: e}); } return; } break; case 37: // left e.data.manager.handler.keyStop(e, opt); if (opt.isInput || !opt.$selected || !opt.$selected.length) { break; } if (!opt.$selected.parent().hasClass('context-menu-root')) { const $parent = opt.$selected.parent().parent(); opt.$selected.trigger('contextmenu:blur', {originalEvent: e}); opt.$selected = $parent; return; } break; case 39: // right e.data.manager.handler.keyStop(e, opt); if (opt.isInput || !opt.$selected || !opt.$selected.length) { break; } const itemdata = opt.$selected.data('contextMenu') || {}; if (itemdata.$menu &amp;&amp; opt.$selected.hasClass('context-menu-submenu')) { opt.$selected = null; itemdata.$selected = null; itemdata.$menu.trigger('nextcommand', {originalEvent: e}); return; } break; case 35: // end case 36: // home if (opt.$selected &amp;&amp; opt.$selected.find('input, textarea, select').length) { break; } else { ((opt.$selected &amp;&amp; opt.$selected.parent()) || opt.$menu) .children(':not(.' + opt.classNames.disabled + ', .' + opt.classNames.notSelectable + ')')[e.keyCode === 36 ? 'first' : 'last']() .trigger('contextmenu:focus', {originalEvent: e}); e.preventDefault(); break; } case 13: // enter e.data.manager.handler.keyStop(e, opt); if (opt.isInput) { if (opt.$selected &amp;&amp; !opt.$selected.is('textarea, select')) { e.preventDefault(); return; } break; } if (typeof opt.$selected !== 'undefined' &amp;&amp; opt.$selected !== null) { opt.$selected.trigger('mouseup', {originalEvent: e}); } return; case 32: // space case 33: // page up case 34: // page down // prevent browser from scrolling down while menu is visible e.data.manager.handler.keyStop(e, opt); return; case 27: // esc e.data.manager.handler.keyStop(e, opt); if (opt.$menu !== null &amp;&amp; typeof opt.$menu !== 'undefined') { opt.$menu.trigger('contextmenu:hide', {originalEvent: e}); } return; default: // 0-9, a-z const k = (String.fromCharCode(e.keyCode)).toUpperCase(); if (opt.accesskeys &amp;&amp; opt.accesskeys[k]) { // according to the specs accesskeys must be invoked immediately opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? 'contextmenu:focus' : 'mouseup', {originalEvent: e}); return; } break; } // pass event to selected item, // stop propagation to avoid endless recursion e.stopPropagation(); if (typeof opt.$selected !== 'undefined' &amp;&amp; opt.$selected !== null) { opt.$selected.trigger(e); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ prevItem(e) { e.stopPropagation(); let opt = $(this).data('contextMenu') || {}; const root = $(this).data('contextMenuRoot') || {}; // obtain currently selected menu if (opt.$selected) { const $s = opt.$selected; opt = opt.$selected.parent().data('contextMenu') || {}; opt.$selected = $s; } const $children = opt.$menu.children(); let $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(); const $round = $prev; // skip disabled or hidden elements while ($prev.hasClass(root.classNames.disabled) || $prev.hasClass(root.classNames.notSelectable) || $prev.is(':hidden')) { if ($prev.prev().length) { $prev = $prev.prev(); } else { $prev = $children.last(); } if ($prev.is($round)) { // break endless loop return; } } // leave current if (opt.$selected) { root.manager.handler.itemMouseleave.call(opt.$selected.get(0), e); } // activate next root.manager.handler.itemMouseenter.call($prev.get(0), e); // focus input const $input = $prev.find('input, textarea, select'); if ($input.length) { $input.focus(); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ nextItem(e) { e.stopPropagation(); let opt = $(this).data('contextMenu') || {}; let root = $(this).data('contextMenuRoot') || {}; // obtain currently selected menu if (opt.$selected) { const $s = opt.$selected; opt = opt.$selected.parent().data('contextMenu') || {}; opt.$selected = $s; } const $children = opt.$menu.children(); let $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(); const $round = $next; // skip disabled while ($next.hasClass(root.classNames.disabled) || $next.hasClass(root.classNames.notSelectable) || $next.is(':hidden')) { if ($next.next().length) { $next = $next.next(); } else { $next = $children.first(); } if ($next.is($round)) { // break endless loop return; } } // leave current if (opt.$selected) { root.manager.handler.itemMouseleave.call(opt.$selected.get(0), e); } // activate next root.manager.handler.itemMouseenter.call($next.get(0), e); // focus input const $input = $next.find('input, textarea, select'); if ($input.length) { $input.focus(); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ focusInput(e) { let $this = $(this).closest('.context-menu-item'); let data = $this.data(); let opt = data.contextMenu; let root = data.contextMenuRoot; root.$selected = opt.$selected = $this; root.isInput = opt.isInput = true; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ blurInput(e) { let $this = $(this).closest('.context-menu-item'); let data = $this.data(); let opt = data.contextMenu; let root = data.contextMenuRoot; root.isInput = opt.isInput = false; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ menuMouseenter(e) { let root = $(this).data().contextMenuRoot; root.hovering = true; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ menuMouseleave(e) { let root = $(this).data().contextMenuRoot; if (root.$layer &amp;&amp; root.$layer.is(e.relatedTarget)) { root.hovering = false; } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ itemMouseenter(e) { let $this = $(this); let data = $this.data(); let opt = data.contextMenu; let root = data.contextMenuRoot; root.hovering = true; // abort if we're re-entering if (e &amp;&amp; root.$layer &amp;&amp; root.$layer.is(e.relatedTarget)) { e.preventDefault(); e.stopImmediatePropagation(); } // make sure only one item is selected (opt.$menu ? opt : root).$menu .children('.' + root.classNames.hover).trigger('contextmenu:blur') .children('.hover').trigger('contextmenu:blur', {originalEvent: e}); if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) { opt.$selected = null; return; } $this.trigger('contextmenu:focus', {originalEvent: e}); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ itemMouseleave(e) { let $this = $(this); let data = $this.data(); let opt = data.contextMenu; let root = data.contextMenuRoot; if (root !== opt &amp;&amp; root.$layer &amp;&amp; root.$layer.is(e.relatedTarget)) { if (typeof root.$selected !== 'undefined' &amp;&amp; root.$selected !== null) { root.$selected.trigger('contextmenu:blur', {originalEvent: e}); } e.preventDefault(); e.stopImmediatePropagation(); root.$selected = opt.$selected = opt.$node; return; } if (opt &amp;&amp; opt.$menu &amp;&amp; opt.$menu.hasClass(root.classNames.visible)) { return; } $this.trigger('contextmenu:blur'); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ itemClick(e) { let $this = $(this); let data = $this.data(); let opt = data.contextMenu; let root = data.contextMenuRoot; let key = data.contextMenuKey; let callback; // abort if the key is unknown or disabled or is a menu if (!opt.items[key] || $this.is('.' + root.classNames.disabled + ', .context-menu-separator, .' + root.classNames.notSelectable) || ($this.is('.context-menu-submenu') &amp;&amp; root.selectableSubMenu === false)) { return; } e.preventDefault(); e.stopImmediatePropagation(); if ($.isFunction(opt.callbacks[key]) &amp;&amp; Object.prototype.hasOwnProperty.call(opt.callbacks, key)) { // item-specific callback callback = opt.callbacks[key]; } else if ($.isFunction(root.callback)) { // default callback callback = root.callback; } else { // no callback, no action return; } // hide menu if callback doesn't stop that if (callback.call(root.$trigger, e, key, opt, root) !== false) { root.$menu.trigger('contextmenu:hide'); } else if (root.$menu.parent().length) { root.manager.operations.update.call(root.$trigger, e, root); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ inputClick(e) { e.stopImmediatePropagation(); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e * @param {Object} data */ hideMenu(e, data) { const root = $(this).data('contextMenuRoot'); root.manager.operations.hide.call(root.$trigger, e, root, data &amp;&amp; data.force); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ focusItem(e) { e.stopPropagation(); const $this = $(this); const data = $this.data(); const opt = data.contextMenu; const root = data.contextMenuRoot; if ($this.hasClass(root.classNames.disabled) || $this.hasClass(root.classNames.notSelectable)) { return; } $this .addClass([root.classNames.hover, root.classNames.visible].join(' ')) // select other items and included items .parent().find('.context-menu-item').not($this) .removeClass(root.classNames.visible) .filter('.' + root.classNames.hover) .trigger('contextmenu:blur'); // remember selected opt.$selected = root.$selected = $this; if (opt.$node &amp;&amp; opt.$node.hasClass('context-menu-submenu')) { opt.$node.addClass(root.classNames.hover); } // position sub-menu - do after show so dumb $.ui.position can keep up if (opt.$node) { root.positionSubmenu.call(opt.$node, e, opt.$menu); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ blurItem(e) { e.stopPropagation(); const $this = $(this); const data = $this.data(); const opt = data.contextMenu; const root = data.contextMenuRoot; if (root.autoHide) { // for tablets and touch screens this needs to remain $this.removeClass(root.classNames.visible); } $this.removeClass(root.classNames.hover); opt.$selected = null; } }; × Search results Close "},"classes_ContextMenuHtml5Builder.js.html":{"id":"classes_ContextMenuHtml5Builder.js.html","title":"Source: classes/ContextMenuHtml5Builder.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: classes/ContextMenuHtml5Builder.js /** * @class ContextMenuHtml5Builder * @classdesc considering the following HTML `$.contextMenu.fromMenu($('#html5menu'))` will return a proper items object. ``` &lt;menu id=&quot;html5menu&quot; type=&quot;context&quot; style=&quot;display:none&quot;&gt; &lt;command label=&quot;rotate&quot; onclick=&quot;alert('rotate')&quot;&gt; &lt;command label=&quot;resize&quot; onclick=&quot;alert('resize')&quot;&gt; &lt;menu label=&quot;share&quot;&gt; &lt;command label=&quot;twitter&quot; onclick=&quot;alert('twitter')&quot;&gt; &lt;hr&gt; &lt;command label=&quot;facebook&quot; onclick=&quot;alert('facebook')&quot;&gt; &lt;/menu&gt; &lt;/menu&gt; ``` `$.contextMenu.fromMenu()` will properly import (and thus handle) the following elements. Everything else is imported as `{type: &quot;html&quot;}` ``` &lt;menu&gt; &lt;hr&gt; &lt;a&gt; &lt;command type=&quot;command|radio|checkbox&quot;&gt; (W3C Specification) &lt;menuitem type=&quot;command|radio|checkbox&quot;&gt; (Firefox) &lt;input type=&quot;text|radio|checkbox&quot;&gt; &lt;select&gt; &lt;textarea&gt; &lt;label for=&quot;someId&quot;&gt; &lt;label&gt; the text &lt;input|textarea|select&gt; ``` The `&lt;menu&gt;` must be hidden but not removed, as all command events (clicks) are passed-thru to the original command element! Note: While the specs note `&lt;option&gt;`s to be renderd as regular commands, `$.contextMenu` will render an actual `&lt;select&gt;`. ## HTML5 `&lt;menu&gt;` shiv/polyfill Engaging the HTML5 polyfill (ignoring `$.contextMenu` if context menus are available natively): ``` $(function(){ $.contextMenu(&quot;html5&quot;); }); ``` Engaging the HTML5 polyfill (ignoring browser native implementation): ``` $(function(){ $.contextMenu(&quot;html5&quot;, true); }); ``` */ export default class ContextMenuHtml5Builder { /** * Get the input label for the given node. * * @method inputLabel * @memberOf ContextMenuHtml5Builder * @instance * * @param {HTMLElement} node - Html element * @returns {string|JQuery|jQuery} - Input label element */ inputLabel(node) { return (node.id &amp;&amp; $('label[for=&quot;' + node.id + '&quot;]').val()) || node.name; } /** * Helper function to build ContextMenuItems from an html5 menu element. * * @method fromMenu * @memberOf ContextMenuHtml5Builder * @instance * * @param {JQuery|string} element - Menu element to generate the menu from. * @returns {Object.&lt;string, ContextMenuItem&gt;} - Collection of {@link ContextMenuItem} */ fromMenu(element) { const $this = $(element); const items = {}; this.build(items, $this.children()); return items; } /** * Helper function for building a menu from a HTML menu element. * * @method build * @memberOf ContextMenuHtml5Builder * @instance * * @param {Object.&lt;string, ContextMenuItem&gt;} items - {@link ContextMenuItem} object to build. * @param {(JQuery)} $children - Collection of elements inside the `&lt;menu&gt;` element * @param {number?} counter - Counter to generate {@link ContextMenuItem} key names. * @returns {number} - Counter to generate {@link ContextMenuItem} key names. */ build(items, $children, counter) { if (!counter) { counter = 0; } let builder = this; $children.each(function () { let $node = $(this); let node = this; let nodeName = this.nodeName.toLowerCase(); let label; let item; // extract &lt;label&gt;&lt;input&gt; if (nodeName === 'label' &amp;&amp; $node.find('input, textarea, select').length) { label = $node.text(); $node = $node.children().first(); node = $node.get(0); nodeName = node.nodeName.toLowerCase(); } /* * &lt;menu&gt; accepts flow-content as children. that means &lt;embed&gt;, &lt;canvas&gt; and such are valid menu items. * Not being the sadistic kind, $.contextMenu only accepts: * &lt;command&gt;, &lt;menuitem&gt;, &lt;hr&gt;, &lt;span&gt;, &lt;p&gt; &lt;input [text, radio, checkbox]&gt;, &lt;textarea&gt;, &lt;select&gt; and of course &lt;menu&gt;. * Everything else will be imported as an html node, which is not interfaced with contextMenu. */ // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command switch (nodeName) { // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element case 'menu': item = {name: $node.attr('label'), items: {}}; counter = builder.build(item.items, $node.children(), counter); break; // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command case 'a': case 'button': item = { name: $node.text(), disabled: !!$node.attr('disabled'), callback: (function () { return function () { $node.get(0).click(); }; })() }; break; // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command case 'menuitem': case 'command': switch ($node.attr('type')) { case undefined: case 'command': case 'menuitem': item = { name: $node.attr('label'), disabled: !!$node.attr('disabled'), icon: $node.attr('icon'), callback: (function () { return function () { $node.get(0).click(); }; })() }; break; case 'checkbox': item = { type: 'checkbox', disabled: !!$node.attr('disabled'), name: $node.attr('label'), selected: !!$node.attr('checked') }; break; case 'radio': item = { type: 'radio', disabled: !!$node.attr('disabled'), name: $node.attr('label'), radio: $node.attr('radiogroup'), value: $node.attr('id'), selected: !!$node.attr('checked') }; break; default: item = undefined; } break; case 'hr': item = '-------'; break; case 'input': switch ($node.attr('type')) { case 'text': item = { type: 'text', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), value: $node.val() }; break; case 'checkbox': item = { type: 'checkbox', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), selected: !!$node.attr('checked') }; break; case 'radio': item = { type: 'radio', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), radio: !!$node.attr('name'), value: $node.val(), selected: !!$node.attr('checked') }; break; default: item = undefined; break; } break; case 'select': item = { type: 'select', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), selected: $node.val(), options: {} }; $node.children().each(function () { item.options[this.value] = $(this).text(); }); break; case 'textarea': item = { type: 'textarea', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), value: $node.val() }; break; case 'label': break; default: item = {type: 'html', html: $node.clone(true)}; break; } if (item) { counter++; items['key' + counter] = item; } }); return counter; } } × Search results Close "},"classes_ContextMenuItemTypes.js.html":{"id":"classes_ContextMenuItemTypes.js.html","title":"Source: classes/ContextMenuItemTypes.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: classes/ContextMenuItemTypes.js /** * @class ContextMenuItem * @instance * @interface * @classdesc The items map contains the commands to list in the menu. Each command has a unique key identifying an item object. The value may either be an item (properties explained below), or a string (which will insert a separator, disregarding the string's content). It is also possible to define a seperator the same as an item, and use the `type`:`cm_separator` to define it. ```javascript var items = { firstCommand: itemOptions, separator1: &quot;-----&quot;, separator2: { &quot;type&quot;: &quot;cm_separator&quot; }, command2: itemOptions } ``` Since 2.3 it is also possible to use a promise as item, so you can build submenu's based on a snynchronous promis. Check out the [demo using a promise](demo/async-promise.md) for an example how to use this. The example uses jQuery deferred, but any promise should do. Promised can only be used in combination with the [build option](docs#build). * * @property {string} name - Specify the human readable name of the command in the menu. This is used as the label for the option. * @property {boolean} isHtmlName - Should this item be called with .html() instead of .text(). Cannot be used with the accesskey option in the same item. * @property {ContextMenuItemCallback} callback - Specifies the callback to execute if the item is clicked. * @property {string} className - Specifies additional classNames to add to the menu item. Seperate multiple classes by using spaces. * @property {ContextMenuIconCallback|string} icon - Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like `.context-menu-item.context-menu-icon-edit`, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. * @property {ContextMenuItemCallback|boolean} disabled - Specifies if the command is disabled (`true`) or enabled (`false`). May be a callback returning a `boolean`. * @property {ContextMenuItemCallback|boolean} visible - Specifies if the command is disabled (`true`) or enabled (`false`). May be a callback returning a `boolean`. * @property {ContextMenuItemTypes|string} type - Specifies the type of the command. See {@link ContextMenuItemTypes}. * @property {Object&lt;string, Function&gt;} events - Events to register on a {@link ContextMenuItem}. The contents of the options object are passed as jQuery `e.data`. * @property {string} value - The value of the `&lt;input&gt;` element. * @property {boolean|string} selected - The selected option of a `select` element and the checked property for `checkbox` and `radio` {@link ContextMenuItemTypes}. * @property {string} radio - Specifies the group of the `radio` element. * @property {string} options - Specifies the options of the `select` element. * @property {Number} height - The height in pixels `&lt;textarea&gt;` element. If not specified, the height is defined by CSS. * @property {Object&lt;string, ContextMenuItem&gt;} items - Items to show in a sub-menu. You can nest as many as you like. * @property {string} accesskey - Character(s) to be used as accesskey. Considering `a b c` $.contextMenu will first try to use »a« as the accesskey, if already taken, it'll fall through to `b`. Words are reduced to the first character, so `hello world` is treated as `h w`. Note: Accesskeys are treated unique throughout one menu. This means an item in a sub-menu can't occupy the same accesskey as an item in the main menu. * * @property {?JQuery} $input - The input element if it was build for this item. * * @property {Object.&lt;string,ContextMenuItem&gt;} items Object containing the menu items. */ /** * Possible ContextMenuItem types * @enum string */ const ContextMenuItemTypes = { /** * The command is a simple clickable item. */ simple: '', /** * Makes the command an &amp;lt;input&amp;gt; of type text. The name followed by the &amp;lt;input&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ text: 'text', /** * Makes the command a &amp;lt;textarea&amp;gt;. The name followed by the &amp;lt;textarea&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ textarea: 'textarea', /** * Makes the command an &amp;lt;input&amp;gt; of type checkbox. The name followed by the &amp;lt;input&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ checkbox: 'checkbox', /** * Makes the command an &amp;lt;input&amp;gt; of type radio. The name followed by the &amp;lt;input&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ radio: 'radio', /** * Makes the command aa &amp;lt;select&amp;gt;. The name followed by the &amp;lt;select&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ select: 'select', /** * Makes an non-command element. When you select `type: 'html'` add the html to the html property. So: `{ item: { type: 'html', html: '&lt;span&gt;html!&lt;/span&gt;' } }`. You can also just use the item name with the `isHtmlName` property. */ html: 'html', /** * Internal property, used internally when the type is set to a string. */ separator: 'cm_separator', /** * Internal property for a {@link ContextMenuItem} that has an `items` property with other {@link ContextMenuItem} items. */ submenu: 'sub' }; export default ContextMenuItemTypes; × Search results Close "},"classes_ContextMenuOperations.js.html":{"id":"classes_ContextMenuOperations.js.html","title":"Source: classes/ContextMenuOperations.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: classes/ContextMenuOperations.js import ContextMenuHelper from './ContextMenuHelper'; import ContextMenuItemTypes from './ContextMenuItemTypes'; export default class ContextMenuOperations { /** * @constructor * @constructs ContextMenuOperations */ constructor() { return this; } /** * Show the menu. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} opt * @param {number} x * @param {number} y */ show(e, opt, x, y) { const $trigger = $(this); const css = {}; // hide any open menus $('#context-menu-layer').trigger('mousedown'); // backreference for callbacks opt.$trigger = $trigger; // show event if (opt.events.show.call($trigger, e, opt) === false) { opt.manager.handler.$currentTrigger = null; return; } // create or update context menu opt.manager.operations.update.call($trigger, e, opt); // position menu opt.position.call($trigger, e, opt, x, y); // make sure we're in front if (opt.zIndex) { let additionalZValue = opt.zIndex; // If opt.zIndex is a function, call the function to get the right zIndex. if (typeof opt.zIndex === 'function') { additionalZValue = opt.zIndex.call($trigger, opt); } css.zIndex = ContextMenuHelper.zindex($trigger) + additionalZValue; } // add layer opt.manager.operations.layer.call(opt.$menu, e, opt, css.zIndex); // adjust sub-menu zIndexes opt.$menu.find('ul').css('zIndex', css.zIndex + 1); // position and show context menu opt.$menu.css(css)[opt.animation.show](opt.animation.duration, () =&gt; { $trigger.trigger('contextmenu:visible'); opt.manager.operations.activated(e, opt); opt.events.activated($trigger, e, opt); }); // make options available and set state $trigger .data('contextMenu', opt) .addClass('context-menu-active'); // register key handler $(document).off('keydown.contextMenu').on('keydown.contextMenu', opt, opt.manager.handler.key); // register autoHide handler if (opt.autoHide) { // mouse position handler $(document).on('mousemove.contextMenuAutoHide', function (e) { // need to capture the offset on mousemove, // since the page might've been scrolled since activation const pos = $trigger.offset(); pos.right = pos.left + $trigger.outerWidth(); pos.bottom = pos.top + $trigger.outerHeight(); if (opt.$layer &amp;&amp; !opt.hovering &amp;&amp; (!(e.pageX &gt;= pos.left &amp;&amp; e.pageX &lt;= pos.right) || !(e.pageY &gt;= pos.top &amp;&amp; e.pageY &lt;= pos.bottom))) { /* Additional hover check after short time, you might just miss the edge of the menu */ setTimeout(function () { if (!opt.hovering &amp;&amp; opt.$menu !== null &amp;&amp; typeof opt.$menu !== 'undefined') { opt.$menu.trigger('contextmenu:hide'); } }, 50); } }); } } /** * Hide the menu. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} opt * @param {boolean} force */ hide(e, opt, force) { const $trigger = $(this); if (typeof opt !== 'object' &amp;&amp; $trigger.data('contextMenu')) { opt = $trigger.data('contextMenu'); } else if (typeof opt !== 'object') { return; } // hide event if (!force &amp;&amp; opt.events &amp;&amp; opt.events.hide.call($trigger, e, opt) === false) { return; } // remove options and revert state $trigger .removeData('contextMenu') .removeClass('context-menu-active'); if (opt.$layer) { // keep layer for a bit so the contextmenu event can be aborted properly by opera setTimeout((function ($layer) { return function () { $layer.remove(); }; })(opt.$layer), 10); try { delete opt.$layer; } catch (e) { opt.$layer = null; } } // remove handle opt.manager.handler.$currentTrigger = null; // remove selected opt.$menu.find('.' + opt.classNames.hover).trigger('contextmenu:blur'); opt.$selected = null; // collapse all submenus opt.$menu.find('.' + opt.classNames.visible).removeClass(opt.classNames.visible); // unregister key and mouse handlers $(document).off('.contextMenuAutoHide').off('keydown.contextMenu'); // hide menu if (opt.$menu) { opt.$menu[opt.animation.hide](opt.animation.duration, function () { // tear down dynamically built menu after animation is completed. if (opt.build) { opt.$menu.remove(); Object.keys(opt).forEach((key) =&gt; { switch (key) { case 'ns': case 'selector': case 'build': case 'trigger': return true; default: opt[key] = undefined; try { delete opt[key]; } catch (e) { } return true; } }); } setTimeout(function () { $trigger.trigger('contextmenu:hidden'); }, 10); }); } } /** * Create a menu based on the options. Also created submenus. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} opt * @param {ContextMenuData?} root */ create(e, opt, root) { if (typeof root === 'undefined') { root = opt; } // create contextMenu opt.$menu = $('&lt;ul class=&quot;context-menu-list&quot;&gt;&lt;/ul&gt;').addClass(opt.className || '').data({ 'contextMenu': opt, 'contextMenuRoot': root }); $.each(['callbacks', 'commands', 'inputs'], function (i, k) { opt[k] = {}; if (!root[k]) { root[k] = {}; } }); if (!root.accesskeys) { root.accesskeys = {}; } function createNameNode(item) { const $name = $('&lt;span&gt;&lt;/span&gt;'); if (item._accesskey) { if (item._beforeAccesskey) { $name.append(document.createTextNode(item._beforeAccesskey)); } $('&lt;span&gt;&lt;/span&gt;') .addClass('context-menu-accesskey') .text(item._accesskey) .appendTo($name); if (item._afterAccesskey) { $name.append(document.createTextNode(item._afterAccesskey)); } } else { if (item.isHtmlName) { // restrict use with access keys if (typeof item.accesskey !== 'undefined') { throw new Error('accesskeys are not compatible with HTML names and cannot be used together in the same item'); } $name.html(item.name); } else { $name.text(item.name); } } return $name; } // create contextMenu items $.each(opt.items, function (key, item) { let $t = $('&lt;li class=&quot;context-menu-item&quot;&gt;&lt;/li&gt;').addClass(item.className || ''); let $label = null; let $input = null; // iOS needs to see a click-event bound to an element to actually // have the TouchEvents infrastructure trigger the click event $t.on('click', $.noop); // Make old school string separator a real item so checks wont be // akward later. // And normalize 'cm_separator' into 'cm_separator'. if (typeof item === 'string' || item.type === 'cm_seperator') { item = {type: ContextMenuItemTypes.separator}; } item.$node = $t.data({ 'contextMenu': opt, 'contextMenuRoot': root, 'contextMenuKey': key }); // register accesskey // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that if (typeof item.accesskey !== 'undefined') { const aks = ContextMenuHelper.splitAccesskey(item.accesskey); for (let i = 0, ak; ak = aks[i]; i++) { if (!root.accesskeys[ak]) { root.accesskeys[ak] = item; const matched = item.name.match(new RegExp('^(.*?)(' + ak + ')(.*)$', 'i')); if (matched) { item._beforeAccesskey = matched[1]; item._accesskey = matched[2]; item._afterAccesskey = matched[3]; } break; } } } if (item.type &amp;&amp; root.types[item.type]) { // run custom type handler root.types[item.type].call($t, item, opt, root); // register commands $.each([opt, root], function (i, k) { k.commands[key] = item; // Overwrite only if undefined or the item is appended to the root. This so it // doesn't overwrite callbacks of root elements if the name is the same. if ($.isFunction(item.callback) &amp;&amp; (typeof k.callbacks[key] === 'undefined' || typeof opt.type === 'undefined')) { k.callbacks[key] = item.callback; } }); } else { // add label for input if (item.type === ContextMenuItemTypes.separator) { $t.addClass('context-menu-separator ' + root.classNames.notSelectable); } else if (item.type === ContextMenuItemTypes.html) { $t.addClass('context-menu-html ' + root.classNames.notSelectable); } else if (item.type &amp;&amp; item.type !== ContextMenuItemTypes.submenu) { $label = $('&lt;label&gt;&lt;/label&gt;').appendTo($t); createNameNode(item).appendTo($label); $t.addClass('context-menu-input'); opt.hasTypes = true; $.each([opt, root], function (i, k) { k.commands[key] = item; k.inputs[key] = item; }); } else if (item.items) { item.type = ContextMenuItemTypes.submenu; } switch (item.type) { case ContextMenuItemTypes.separator: break; case ContextMenuItemTypes.text: $input = $('&lt;input type=&quot;text&quot; value=&quot;1&quot; name=&quot;&quot; /&gt;') .attr('name', 'context-menu-input-' + key) .val(item.value || '') .appendTo($label); break; case ContextMenuItemTypes.textarea: $input = $('&lt;textarea name=&quot;&quot;&gt;&lt;/textarea&gt;') .attr('name', 'context-menu-input-' + key) .val(item.value || '') .appendTo($label); if (item.height) { $input.height(item.height); } break; case ContextMenuItemTypes.checkbox: $input = $('&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; name=&quot;&quot; /&gt;') .attr('name', 'context-menu-input-' + key) .val(item.value || '') .prop('checked', !!item.selected) .prependTo($label); break; case ContextMenuItemTypes.radio: $input = $('&lt;input type=&quot;radio&quot; value=&quot;1&quot; name=&quot;&quot; /&gt;') .attr('name', 'context-menu-input-' + item.radio) .val(item.value || '') .prop('checked', !!item.selected) .prependTo($label); break; case ContextMenuItemTypes.select: $input = $('&lt;select name=&quot;&quot;&gt;&lt;/select&gt;') .attr('name', 'context-menu-input-' + key) .appendTo($label); if (item.options) { $.each(item.options, function (value, text) { $('&lt;option&gt;&lt;/option&gt;').val(value).text(text).appendTo($input); }); $input.val(item.selected); } break; case ContextMenuItemTypes.submenu: createNameNode(item).appendTo($t); item.appendTo = item.$node; $t.data('contextMenu', item).addClass('context-menu-submenu'); item.callback = null; // If item contains items, and this is a promise, we should create it later // check if subitems is of type promise. If it is a promise we need to create // it later, after promise has been resolved. if (typeof item.items.then === 'function') { // probably a promise, process it, when completed it will create the sub menu's. root.manager.operations.processPromises(e, item, root, item.items); } else { // normal submenu. root.manager.operations.create(e, item, root); } break; case ContextMenuItemTypes.html: $(item.html).appendTo($t); break; default: $.each([opt, root], function (i, k) { k.commands[key] = item; // Overwrite only if undefined or the item is appended to the root. This so it // doesn't overwrite callbacks of root elements if the name is the same. if ($.isFunction(item.callback) &amp;&amp; (typeof k.callbacks[key] === 'undefined' || typeof opt.type === 'undefined')) { k.callbacks[key] = item.callback; } }); createNameNode(item).appendTo($t); break; } // disable key listener in &lt;input&gt; if (item.type &amp;&amp; item.type !== ContextMenuItemTypes.submenu &amp;&amp; item.type !== ContextMenuItemTypes.html &amp;&amp; item.type !== ContextMenuItemTypes.separator) { $input .on('focus', root.manager.handler.focusInput) .on('blur', root.manager.handler.blurInput); if (item.events) { $input.on(item.events, opt); } } // add icons if (item.icon) { if ($.isFunction(item.icon)) { item._icon = item.icon.call(this, e, $t, key, item, opt, root); } else { if (typeof (item.icon) === 'string' &amp;&amp; item.icon.substring(0, 3) === 'fa-') { // to enable font awesome item._icon = root.classNames.icon + ' ' + root.classNames.icon + '--fa fa ' + item.icon; } else { item._icon = root.classNames.icon + ' ' + root.classNames.icon + '-' + item.icon; } } $t.addClass(item._icon); } } // cache contained elements item.$input = $input; item.$label = $label; // attach item to menu $t.appendTo(opt.$menu); // Disable text selection if (!opt.hasTypes &amp;&amp; $.support.eventSelectstart) { // browsers support user-select: none, // IE has a special event for text-selection // browsers supporting neither will not be preventing text-selection $t.on('selectstart.disableTextSelect', opt.manager.handler.abortevent); } }); // attach contextMenu to &lt;body&gt; (to bypass any possible overflow:hidden issues on parents of the trigger element) if (!opt.$node) { opt.$menu.css('display', 'none').addClass('context-menu-root'); } opt.$menu.appendTo(opt.appendTo || document.body); } /** * Resize the menu to its content. * * @method * @memberOf ContextMenuOperations * @instance * * @param {ContextMenuEvent} e * @param {JQuery} $menu * @param {boolean?} nested */ resize(e, $menu, nested) { let domMenu; // determine widths of submenus, as CSS won't grow them automatically // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100; // kinda sucks hard... // determine width of absolutely positioned element $menu.css({position: 'absolute', display: 'block'}); // don't apply yet, because that would break nested elements' widths $menu.data('width', (domMenu = $menu.get(0)).getBoundingClientRect ? Math.ceil(domMenu.getBoundingClientRect().width) : $menu.outerWidth() + 1); // outerWidth() returns rounded pixels // reset styles so they allow nested elements to grow/shrink naturally $menu.css({ position: 'static', minWidth: '0px', maxWidth: '100000px' }); // identify width of nested menus $menu.find('&gt; li &gt; ul').each((index, element) =&gt; { e.data.manager.operations.resize(e, $(element), true); }); // reset and apply changes in the end because nested // elements' widths wouldn't be calculatable otherwise if (!nested) { $menu.find('ul').addBack().css({ position: '', display: '', minWidth: '', maxWidth: '' }).outerWidth(function () { return $(this).data('width'); }); } } /** * Update the contextmenu, re-evaluates the whole menu (including disabled/visible callbacks) * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData?} opt * @param {ContextMenuData?} root */ update(e, opt, root) { const $trigger = this; if (typeof root === 'undefined') { root = opt; root.manager.operations.resize(e, opt.$menu); } // re-check disabled for each item opt.$menu.children().each(function (index, element) { let $item = $(element); let key = $item.data('contextMenuKey'); let item = opt.items[key]; let disabled = ($.isFunction(item.disabled) &amp;&amp; item.disabled.call($trigger, e, key, opt, root)) || item.disabled === true; let visible; if ($.isFunction(item.visible)) { visible = item.visible.call($trigger, e, key, opt, root); } else if (typeof item.visible !== 'undefined') { visible = item.visible === true; } else { visible = true; } $item[visible ? 'show' : 'hide'](); // dis- / enable item $item[disabled ? 'addClass' : 'removeClass'](root.classNames.disabled); if ($.isFunction(item.icon)) { $item.removeClass(item._icon); item._icon = item.icon.call(this, $trigger, $item, key, item); $item.addClass(item._icon); } if (item.type) { // dis- / enable input elements $item.find('input, select, textarea').prop('disabled', disabled); // update input states switch (item.type) { case ContextMenuItemTypes.text: case ContextMenuItemTypes.textarea: item.$input.val(item.value || ''); break; case ContextMenuItemTypes.checkbox: case ContextMenuItemTypes.radio: item.$input.val(item.value || '').prop('checked', !!item.selected); break; case ContextMenuItemTypes.select: item.$input.val((item.selected === 0 ? '0' : item.selected) || ''); break; } } if (item.$menu) { // update sub-menu root.manager.operations.update.call($trigger, e, item, root); } }); } /** * Create the overlay layer so we can capture the click outside the menu and close it. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} opt * @param {number} zIndex * @returns {jQuery} */ layer(e, opt, zIndex) { const $window = $(window); // add transparent layer for click area // filter and background for Internet Explorer, Issue #23 const $layer = opt.$layer = $('&lt;div id=&quot;context-menu-layer&quot;&gt;&lt;/div&gt;') .css({ height: $window.height(), width: $window.width(), display: 'block', position: 'fixed', 'z-index': zIndex, top: 0, left: 0, opacity: 0, filter: 'alpha(opacity=0)', 'background-color': '#000' }) .data('contextMenuRoot', opt) .insertBefore(this) .on('contextmenu', opt.manager.handler.abortevent) .on('mousedown', opt.manager.handler.layerClick); // IE6 doesn't know position:fixed; if (typeof document.body.style.maxWidth === 'undefined') { // IE6 doesn't support maxWidth $layer.css({ 'position': 'absolute', 'height': $(document).height() }); } return $layer; } /** * Process submenu promise. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} opt * @param {ContextMenuData} root * @param {Promise} promise */ processPromises(e, opt, root, promise) { // Start opt.$node.addClass(root.classNames.iconLoadingClass); function finishPromiseProcess(opt, root, items) { if (typeof root.$menu === 'undefined' || !root.$menu.is(':visible')) { return; } opt.$node.removeClass(root.classNames.iconLoadingClass); opt.items = items; root.manager.operations.create(e, opt, root); // Create submenu root.manager.operations.update(e, opt, root); // Correctly update position if user is already hovered over menu item root.positionSubmenu.call(opt.$node, e, opt.$menu); // positionSubmenu, will only do anything if user already hovered over menu item that just got new subitems. } function errorPromise(opt, root, errorItem) { // User called promise.reject() with an error item, if not, provide own error item. if (typeof errorItem === 'undefined') { errorItem = { 'error': { name: 'No items and no error item', icon: 'context-menu-icon context-menu-icon-quit' } }; if (window.console) { (console.error || console.log).call(console, 'When you reject a promise, provide an &quot;items&quot; object, equal to normal sub-menu items'); } } else if (typeof errorItem === 'string') { errorItem = {'error': {name: errorItem}}; } finishPromiseProcess(opt, root, errorItem); } function completedPromise(opt, root, items) { // Completed promise (dev called promise.resolve). We now have a list of items which can // be used to create the rest of the context menu. if (typeof items === 'undefined') { // Null result, dev should have checked errorPromise(undefined); // own error object } finishPromiseProcess(opt, root, items); } // Wait for promise completion. .then(success, error, notify) (we don't track notify). Bind the opt // and root to avoid scope problems promise.then(completedPromise.bind(this, opt, root), errorPromise.bind(this, opt, root)); } /** * Operation that will run after contextMenu showed on screen. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} opt * @return {undefined} */ activated(e, opt) { const $menu = opt.$menu; const $menuOffset = $menu.offset(); const winHeight = $(window).height(); const winScrollTop = $(window).scrollTop(); const menuHeight = $menu.height(); if (menuHeight &gt; winHeight) { $menu.css({ 'height': winHeight + 'px', 'overflow-x': 'hidden', 'overflow-y': 'auto', 'top': winScrollTop + 'px' }); } else if (($menuOffset.top &lt; winScrollTop) || ($menuOffset.top + menuHeight &gt; winScrollTop + winHeight)) { $menu.css({ 'top': '0px' }); } } }; × Search results Close "},"jquery_contextMenuFunction.js.html":{"id":"jquery_contextMenuFunction.js.html","title":"Source: jquery/contextMenuFunction.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: jquery/contextMenuFunction.js /** * The jQuery plugin namespace. * @external &quot;jQuery.fn&quot; * @see {@link http://docs.jquery.com/Plugins/Authoring The jQuery Plugin Guide} */ /** * Function that is called when calling contextmenu on an element (eg. $('.contextmenu').contextMenu()). * * @instance * @function external:jQuery.fn.contextmenu * * @param {(string|Object)} operation * @returns {JQuery} */ export default function (operation) { const $t = this; const $o = operation; if ($t.length &gt; 0) { // this is not a build on demand menu if (typeof operation === 'undefined') { $t.first().trigger('contextmenu'); } else if (typeof operation.x !== 'undefined' &amp;&amp; typeof operation.y !== 'undefined') { $t.first().trigger($.Event('contextmenu', { pageX: operation.x, pageY: operation.y, mouseButton: operation.button })); } else if (operation === 'hide') { const $menu = this.first().data('contextMenu') ? this.first().data('contextMenu').$menu : null; if ($menu) { $menu.trigger('contextmenu:hide'); } } else if (operation === 'destroy') { $.contextMenu('destroy', {context: this}); } else if ($.isPlainObject(operation)) { operation.context = this; $.contextMenu('create', operation); } else if (operation === true) { $t.removeClass('context-menu-disabled'); } else if (operation === false) { $t.addClass('context-menu-disabled'); } } else { // eslint-disable-next-line no-undef $.each($.contextMenu.menus, function () { if (this.selector === $t.selector) { $o.data = this; $.extend($o.data, {trigger: 'demand'}); } }); $.contextMenu.handle.contextmenu.call($o.target, $o); } return this; } × Search results Close "},"contextmenu.js.html":{"id":"contextmenu.js.html","title":"Source: contextmenu.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: contextmenu.js 'use strict'; import '../sass/jquery.contextMenu.scss'; import ContextMenu from './classes/ContextMenu'; import elementFunction from './jquery/contextMenuFunction'; /** * The jQuery namespace. * @external &quot;jQuery&quot; * @see {@link http://docs.jquery.com/Plugins/Authoring The jQuery Plugin Guide} */ /** * @class jQuery.contextMenu * @function external:jQuery.contextMenu * @instance * * @param {string} operation * @param {ContextMenuSettings} options * * @property {ContextMenu} manager * @property {getInputValues} getInputValues * @property {setInputValues} setInputValues * @property {fromMenu} ContextMenuHtml5Builder#fromMenu * @property {ContextMenuSettings} defaults * @property {ContextMenuEventHandler} handle * @property {ContextMenuOperations} operations * @property {Object&lt;string, ContextMenuData&gt;} menus */ const manager = new ContextMenu(); // manage contextMenu instances let contextMenu = function (operation, options) { manager.execute(operation, options); }; contextMenu.getInputValues = function (opt, data) { return manager.getInputValues(opt, data); }; contextMenu.setInputValues = function (opt, data) { return manager.getInputValues(opt, data); }; contextMenu.fromMenu = function (element) { return manager.html5builder.fromMenu(element); }; // make defaults accessible contextMenu.defaults = manager.defaults; contextMenu.types = manager.defaults.types; contextMenu.manager = manager; // export internal functions - undocumented, for hacking only! contextMenu.handle = manager.handler; contextMenu.operations = manager.operations; contextMenu.menus = manager.menus; contextMenu.namespaces = manager.namespaces; $.fn.contextMenu = elementFunction; $.contextMenu = contextMenu; module.exports = ContextMenu; × Search results Close "},"classes_ContextMenuHelper.js.html":{"id":"classes_ContextMenuHelper.js.html","title":"Source: classes/ContextMenuHelper.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Source: classes/ContextMenuHelper.js export default class ContextMenuHelper { /** * @param {JQuery} $t - Element to calculate z-index of. * @return {number} - Elements zIndex */ static zindex($t) { let zin = 0; let $tt = $t; while (true) { zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0); $tt = $tt.parent(); if (!$tt || !$tt.length || 'html body'.indexOf($tt.prop('nodeName').toLowerCase()) &gt; -1) { break; } } return zin; } /** * Split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key * @param {string} val - Accesskey value * @return {Array} - Seperate keys to handle as accesskey */ static splitAccesskey(val) { let t = val.split(/\\s+/); let keys = []; for (let i = 0, k; k = t[i]; i++) { k = k.charAt(0).toUpperCase(); // first character only // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it. // a map to look up already used access keys would be nice keys.push(k); } return keys; } } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Global Members &lt;constant&gt; ContextMenuItemTypes Possible ContextMenuItem types Properties: Name Type Default Description simple The command is a simple clickable item. text text Makes the command an &lt;input&gt; of type text. The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. textarea textarea Makes the command a &lt;textarea&gt;. The name followed by the &lt;textarea&gt; are encapsulated in a &lt;label&gt;. checkbox checkbox Makes the command an &lt;input&gt; of type checkbox. The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. radio radio Makes the command an &lt;input&gt; of type radio. The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. select select Makes the command aa &lt;select&gt;. The name followed by the &lt;select&gt; are encapsulated in a &lt;label&gt;. html html Makes an non-command element. When you select type: 'html' add the html to the html property. So: { item: { type: 'html', html: '&lt;span&gt;html!&lt;/span&gt;' } }. You can also just use the item name with the isHtmlName property. separator cm_separator Internal property, used internally when the type is set to a string. submenu sub Internal property for a ContextMenuItem that has an items property with other ContextMenuItem items. Source: classes/ContextMenuItemTypes.js, line 51 Methods splitAccesskey(val) Split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key Parameters: Name Type Description val string Accesskey value Source: classes/ContextMenuHelper.js, line 26 Returns: Seperate keys to handle as accesskey Type Array zindex($t) Parameters: Name Type Description $t JQuery Element to calculate z-index of. Source: classes/ContextMenuHelper.js, line 7 Returns: Elements zIndex Type number Type Definitions ContextMenuBuildCallback(e, $currentTrigger) Parameters: Name Type Description e JQuery.Event Event that trigged the menu. $currentTrigger JQuery Element that trigged the menu. Source: defaults/interfaces.js, line 80 Returns: Type Object.&lt;string, ContextMenuItem&gt; ContextMenuEvent Type: jQuery.Event Properties: Name Type Description data ContextMenuData Source: classes/ContextMenuEventHandler.js, line 3 ContextMenuIconCallback(e,, $t, key, item, opt, root) Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like .context-menu-item.context-menu-icon-edit, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. Parameters: Name Type Description e, ContextMenuEvent | JQuery.Event $t JQuery key string item ContextMenuItem opt ContextMenuData root ContextMenuData Source: defaults/interfaces.js, line 35 Example var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, opt, root){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + opt.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } ContextMenuIconCallback(e,, $t, key, item, opt, root) Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like .context-menu-item.context-menu-icon-edit, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. Parameters: Name Type Description e, ContextMenuEvent | JQuery.Event $t JQuery key string item ContextMenuItem opt ContextMenuData root ContextMenuData Source: defaults/interfaces.js, line 1 Example var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, opt, root){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + opt.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } ContextMenuItemCallback(e, key, opt, root) The Callback is executed in the context of the triggering object. Parameters: Name Type Description e JQuery.Event Event that trigged the menu. key string Key of the menu item. opt ContextMenuData Data of the (sub)menu in which the item resides. root ContextMenuData Data of the root menu in which the item resides. Might be the same as opt if triggered in the menu root. Source: defaults/interfaces.js, line 69 Returns: Type boolean × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Classes Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Interfaces Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Externals Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Tutorials Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery jQuery contextMenu plugin &amp; polyfill $.contextMenu is a management facility for - you guessed it - context menus. It was designed for an application where there are hundreds of elements that may show a context menu - so intialization speed and memory usage are kept fairly small. It also allows to register context menus without providing actual markup, as $.contextMenu generates DOMElements as needed. features -demo -documentation Dependencies jQuery &gt;=1.8.2 jQuery UI position (optional but recommended) Usageregister contextMenu from javascript: $.contextMenu({ // define which elements trigger this menu selector: &quot;.with-cool-menu&quot;, // define the elements of the menu items: { foo: {name: &quot;Foo&quot;, callback: function(key, opt){ alert(&quot;Foo!&quot;); }}, bar: {name: &quot;Bar&quot;, callback: function(key, opt){ alert(&quot;Bar!&quot;) }} } // there's more, have a look at the demos and docs... });have a look at the demos. HTML5 CompatibilityFirefox 8 implemented contextmenu using the &lt;menuitem&gt; tags for menu-structure. The specs however state that &lt;command&gt; tags should be used for this purpose. $.contextMenu accepts both. Firefox 8 does not yet fully implement the contextmenu specification (Ticket #617528). The elementsa,button,input andoptionusable as commands are being ignored altogether. It also doesn't (optically) distinguish between checkbox/radio and regular commands (Bug #705292). contextmenu specs command specs Browser support according to caniuse.com Note: While the specs note &lt;option&gt;s to be renderd as regular commands, $.contextMenu will render an actual &lt;select&gt;. import contextMenu from HTML5 &lt;menu&gt;: $.contextMenu(&quot;html5&quot;);Interaction PrinciplesYou're (obviously) able to use the context menu with your mouse. Once it is opened, you can also use the keyboard to (fully) navigate it. ↑ (up) previous item in list, will skip disabled elements and wrap around ↓ (down) next item in, will skip disabled elements and wrap around → (right) dive into sub-menu ← (left) rise from sub-menu ↵ (return) invoke command ⇥ (tab) next item or input element, will skip disabled elements and wrap around ⇪ ⇥ (shift tab) previous item or input element, will skip disabled elements and wrap around ⎋ (escape) close menu ⌴ (space) captured and ignore to avoid page scrolling (for consistency with native menus) ⇞ (page up) captured and ignore to avoid page scrolling (for consistency with native menus) ⇟ (page down) captured and ignore to avoid page scrolling (for consistency with native menus) ↖ (home) first item in list, will skip disabled elements ↘ (end) last item in list, will skip disabled elements Besides the obvious, browser also react to alphanumeric key strokes. Hitting r in a context menu will make Firefox (8) reload the page immediately. Chrome selects the option to see infos on the page, Safari selects the option to print the document. Awesome, right? Until trying the same on Windows I did not realize that the browsers were using the access-key for this. I would've preferred typing the first character of something, say &quot;s&quot; for &quot;save&quot; and then iterate through all the commands beginning with s. But that's me - what do I know about UX? Anyways, $.contextMenu now also supports accesskey handling. Authors Björn Brala Rodney Rehm (original creator) Christiaan Baartse (single callback per menu) Addy Osmani (compatibility with native context menu in Firefox 8) License$.contextMenu is published under the MIT license Special thanksFont-Awesome icons used from encharm/Font-Awesome-SVG-PNG. × Search results Close "},"ContextMenu.html":{"id":"ContextMenu.html","title":"Class: ContextMenu","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Class: ContextMenu ContextMenu The ContextMenu is the core class that manages contextmenu's. You can call this class directly and skip going through jQuery. new ContextMenu() Properties: Name Type Description defaults ContextMenuSettings | Object handle ContextMenuEventHandler operations ContextMenuOperations menus Object.&lt;string, ContextMenuData&gt; counter number Internal counter to keep track of different menu's on the page. initialized boolean Flag the menu as initialized. Source: classes/ContextMenu.js, line 7 Example // You can call this class directly and skip going through jQuery, although it still requires jQuery to run. const manager = new ContextMenu(); manager.execute(&quot;create&quot;, options); Methods execute(operation, options) Parameters: Name Type Description operation string | ContextMenuSettings options string | ContextMenuSettings Source: classes/ContextMenu.js, line 36 Returns: Type ContextMenu getInputValues(opt, data) export values from &lt;input&gt; commands Parameters: Name Type Description opt ContextMenuData ContextMenuData object data Object Values object Source: classes/ContextMenu.js, line 308 Returns: Values of input elements Type Object setInputValues(opt, data) import values into &lt;input&gt; commands Parameters: Name Type Description opt ContextMenuData ContextMenuData object data Object Values to set Source: classes/ContextMenu.js, line 270 Returns: Type undefined × Search results Close "},"ContextMenuData.html":{"id":"ContextMenuData.html","title":"Interface: ContextMenuData","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Interface: ContextMenuData ContextMenuData Properties: Name Type Argument Description $menu JQuery The menu element for this menu part. Eg. the root menu, or a single submenu. $layer JQuery The opened layer when the menu is opened. $node JQuery The menu node. $trigger JQuery The element that triggered opening the menu. $selected JQuery Reference to the &lt;li&gt; command element. $input JQuery Reference to the &lt;input&gt; or &lt;select&gt; of the command element. $label JQuery Reference to the &lt;input&gt; or &lt;select&gt; of the command element. ns string The namespace (including leading dot) all events for this contextMenu instance were registered under. manager ContextMenu The contextmenu manager instance. $selected JQuery | jQuery | null Currently selected menu item, or input inside menu item. hasTypes boolean &lt;nullable&gt; The menu has ContextMenuItem which are of a selectable type. isInput boolean &lt;nullable&gt; We are currently originating events from an input. inputs Object.&lt;string, ContextMenuItem&gt; Inputs defined in the menu. hovering boolean Currently hovering, root menu only. Source: defaults/index.js, line 3 Extends ContextMenuSettings Methods determinePosition($menu) Determine the position for a root menu. Parameters: Name Type Description $menu JQuery Inherited From: ContextMenuSettings#determinePosition Source: defaults/position.js, line 1 position(e, opt, x, y) Position the root menu. Parameters: Name Type Description e JQuery.Event opt ContextMenuData x number | string y number | string Inherited From: ContextMenuSettings#position Source: defaults/position.js, line 28 positionSubmenu(e, $menu) Position a submenu. Parameters: Name Type Description e JQuery.Event $menu JQuery Inherited From: ContextMenuSettings#positionSubmenu Source: defaults/position.js, line 78 × Search results Close "},"ContextMenuEventHandler.html":{"id":"ContextMenuEventHandler.html","title":"Class: ContextMenuEventHandler","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Class: ContextMenuEventHandler ContextMenuEventHandler new ContextMenuEventHandler() Properties: Name Type Argument Description $currentTrigger JQuery &lt;nullable&gt; hoveract Object Source: classes/ContextMenuEventHandler.js, line 16 Methods abortevent(e) Helper to abort an event Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 30 blurInput(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 666 blurItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 877 click(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 135 contextmenu(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 42 focusInput(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 649 focusItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 838 hideMenu(e, data) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event data Object Source: classes/ContextMenuEventHandler.js, line 826 inputClick(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 814 itemClick(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 772 itemMouseenter(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 708 itemMouseleave(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 742 key(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 371 keyStop(e, opt) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event opt ContextMenuItem Source: classes/ContextMenuEventHandler.js, line 356 layerClick(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 263 menuMouseenter(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 682 menuMouseleave(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 694 mousedown(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 148 mouseenter(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 190 mouseleave(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 240 mousemove(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 228 mouseup(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 170 nextItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 598 prevItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 546 × Search results Close "},"ContextMenuHtml5Builder.html":{"id":"ContextMenuHtml5Builder.html","title":"Class: ContextMenuHtml5Builder","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Class: ContextMenuHtml5Builder ContextMenuHtml5Builder considering the following HTML $.contextMenu.fromMenu($('#html5menu')) will return a proper items object. &lt;menu id=&quot;html5menu&quot; type=&quot;context&quot; style=&quot;display:none&quot;&gt; &lt;command label=&quot;rotate&quot; onclick=&quot;alert('rotate')&quot;&gt; &lt;command label=&quot;resize&quot; onclick=&quot;alert('resize')&quot;&gt; &lt;menu label=&quot;share&quot;&gt; &lt;command label=&quot;twitter&quot; onclick=&quot;alert('twitter')&quot;&gt; &lt;hr&gt; &lt;command label=&quot;facebook&quot; onclick=&quot;alert('facebook')&quot;&gt; &lt;/menu&gt; &lt;/menu&gt; $.contextMenu.fromMenu() will properly import (and thus handle) the following elements. Everything else is imported as {type: &quot;html&quot;} &lt;menu&gt; &lt;hr&gt; &lt;a&gt; &lt;command type=&quot;command|radio|checkbox&quot;&gt; (W3C Specification) &lt;menuitem type=&quot;command|radio|checkbox&quot;&gt; (Firefox) &lt;input type=&quot;text|radio|checkbox&quot;&gt; &lt;select&gt; &lt;textarea&gt; &lt;label for=&quot;someId&quot;&gt; &lt;label&gt; the text &lt;input|textarea|select&gt; The &lt;menu&gt; must be hidden but not removed, as all command events (clicks) are passed-thru to the original command element! Note: While the specs note &lt;option&gt;s to be renderd as regular commands, $.contextMenu will render an actual &lt;select&gt;. HTML5 &lt;menu&gt; shiv/polyfill Engaging the HTML5 polyfill (ignoring $.contextMenu if context menus are available natively): $(function(){ $.contextMenu(&quot;html5&quot;); }); Engaging the HTML5 polyfill (ignoring browser native implementation): $(function(){ $.contextMenu(&quot;html5&quot;, true); }); new ContextMenuHtml5Builder() Source: classes/ContextMenuHtml5Builder.js, line 1 Methods build(items, $children, counter) Helper function for building a menu from a HTML menu element. Parameters: Name Type Argument Description items Object.&lt;string, ContextMenuItem&gt; ContextMenuItem object to build. $children JQuery Collection of elements inside the &lt;menu&gt; element counter number &lt;nullable&gt; Counter to generate ContextMenuItem key names. Source: classes/ContextMenuHtml5Builder.js, line 89 Returns: Counter to generate ContextMenuItem key names. Type number fromMenu(element) Helper function to build ContextMenuItems from an html5 menu element. Parameters: Name Type Description element JQuery | string Menu element to generate the menu from. Source: classes/ContextMenuHtml5Builder.js, line 70 Returns: Collection of ContextMenuItem Type Object.&lt;string, ContextMenuItem&gt; inputLabel(node) Get the input label for the given node. Parameters: Name Type Description node HTMLElement Html element Source: classes/ContextMenuHtml5Builder.js, line 56 Returns: Input label element Type string | JQuery | jQuery × Search results Close "},"ContextMenuItem.html":{"id":"ContextMenuItem.html","title":"Interface: ContextMenuItem","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Interface: ContextMenuItem ContextMenuItem The items map contains the commands to list in the menu. Each command has a unique key identifying an item object. The value may either be an item (properties explained below), or a string (which will insert a separator, disregarding the string's content). It is also possible to define a seperator the same as an item, and use the type:cm_separator to define it. var items = { firstCommand: itemOptions, separator1: &quot;-----&quot;, separator2: { &quot;type&quot;: &quot;cm_separator&quot; }, command2: itemOptions } Since 2.3 it is also possible to use a promise as item, so you can build submenu's based on a snynchronous promis. Check out the demo using a promise for an example how to use this. The example uses jQuery deferred, but any promise should do. Promised can only be used in combination with the build option. Properties: Name Type Argument Description name string Specify the human readable name of the command in the menu. This is used as the label for the option. isHtmlName boolean Should this item be called with .html() instead of .text(). Cannot be used with the accesskey option in the same item. callback ContextMenuItemCallback Specifies the callback to execute if the item is clicked. className string Specifies additional classNames to add to the menu item. Seperate multiple classes by using spaces. icon ContextMenuIconCallback | string Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like .context-menu-item.context-menu-icon-edit, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. disabled ContextMenuItemCallback | boolean Specifies if the command is disabled (true) or enabled (false). May be a callback returning a boolean. visible ContextMenuItemCallback | boolean Specifies if the command is disabled (true) or enabled (false). May be a callback returning a boolean. type ContextMenuItemTypes | string Specifies the type of the command. See ContextMenuItemTypes. events Object.&lt;string, function()&gt; Events to register on a ContextMenuItem. The contents of the options object are passed as jQuery e.data. value string The value of the &lt;input&gt; element. selected boolean | string The selected option of a select element and the checked property for checkbox and radio ContextMenuItemTypes. radio string Specifies the group of the radio element. options string Specifies the options of the select element. height Number The height in pixels &lt;textarea&gt; element. If not specified, the height is defined by CSS. items Object.&lt;string, ContextMenuItem&gt; Items to show in a sub-menu. You can nest as many as you like. accesskey string Character(s) to be used as accesskey. Considering a b c $.contextMenu will first try to use »a« as the accesskey, if already taken, it'll fall through to b. Words are reduced to the first character, so hello world is treated as h w. Note: Accesskeys are treated unique throughout one menu. This means an item in a sub-menu can't occupy the same accesskey as an item in the main menu. $input JQuery &lt;nullable&gt; The input element if it was build for this item. items Object.&lt;string, ContextMenuItem&gt; Object containing the menu items. Source: classes/ContextMenuItemTypes.js, line 1 × Search results Close "},"ContextMenuOperations.html":{"id":"ContextMenuOperations.html","title":"Class: ContextMenuOperations","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Class: ContextMenuOperations ContextMenuOperations new ContextMenuOperations() Source: classes/ContextMenuOperations.js, line 9 Methods activated(e, opt) Operation that will run after contextMenu showed on screen. Parameters: Name Type Description e JQuery.Event opt ContextMenuData Source: classes/ContextMenuOperations.js, line 690 Returns: Type undefined create(e, opt, root) Create a menu based on the options. Also created submenus. Parameters: Name Type Argument Description e JQuery.Event opt ContextMenuData root ContextMenuData &lt;nullable&gt; Source: classes/ContextMenuOperations.js, line 195 hide(e, opt, force) Hide the menu. Parameters: Name Type Description e JQuery.Event opt ContextMenuData force boolean Source: classes/ContextMenuOperations.js, line 110 layer(e, opt, zIndex) Create the overlay layer so we can capture the click outside the menu and close it. Parameters: Name Type Description e JQuery.Event opt ContextMenuData zIndex number Source: classes/ContextMenuOperations.js, line 585 Returns: Type jQuery processPromises(e, opt, root, promise) Process submenu promise. Parameters: Name Type Description e JQuery.Event opt ContextMenuData root ContextMenuData promise Promise Source: classes/ContextMenuOperations.js, line 631 resize(e, $menu, nested) Resize the menu to its content. Parameters: Name Type Argument Description e ContextMenuEvent $menu JQuery nested boolean &lt;nullable&gt; Source: classes/ContextMenuOperations.js, line 463 show(e, opt, x, y) Show the menu. Parameters: Name Type Description e JQuery.Event opt ContextMenuData x number y number Source: classes/ContextMenuOperations.js, line 25 update(e, opt, root) Update the contextmenu, re-evaluates the whole menu (including disabled/visible callbacks) Parameters: Name Type Argument Description e JQuery.Event opt ContextMenuData &lt;nullable&gt; root ContextMenuData &lt;nullable&gt; Source: classes/ContextMenuOperations.js, line 511 × Search results Close "},"ContextMenuSettings.html":{"id":"ContextMenuSettings.html","title":"Interface: ContextMenuSettings","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Interface: ContextMenuSettings ContextMenuSettings Register new contextMenu To register a new contextMenu: $.contextMenu( contextMenuOptions );Update contextMenu state It is possible to refresh the state of the contextmenu disabled, visibility, icons and input values through the update command. This will reevaluate any custom callbacks. $('.context-menu-one').contextMenu('update'); // update single menu $.contextMenu('update') // update all open menus Properties: Name Type Argument Default Description selector null | string Selector on which the contextMenu triggers. items Object.&lt;string, ContextMenuItem&gt; Object with items to be listed in contextMenu. See ContextMenuItem for a full documentation on how to build your menu items. appendTo JQuery.Selector | DOMElement &lt;optional&gt; document.body Specifies the selector string or DOMElement the generated menu is to be appended to. trigger 'right' | 'left' | 'hover' | 'touchstart' | 'none' left Method to trigger context menu [&quot;right&quot;, &quot;left&quot;, &quot;hover&quot;, &quot;touchstart&quot;, &quot;none&quot;]. itemClickEvent string &lt;nullable&gt; Allows the selection of the click event instead of the mouseup event to handle the user mouse interaction with the contexMenu. The default event is mouseup. Set the option to &quot;click&quot; to change to the click event. This option is global: the first contexMenu registered sets it. To change it afterwards all the contextMenu have to be unregistered with $.contextMenu( 'destroy' ); before the change has effect again. hideOnSecondTrigger boolean false Flag denoting if a second trigger should close the menu, as long as the trigger happened on one of the trigger-element's child nodes. This overrides the reposition option. selectableSubMenu boolean false Ability to select ContextMenuItem containing a submenu. reposition boolean true flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu as long as the trigger happened on one of the trigger-element's child nodes delay number 200 ms to wait before showing a hover-triggered context menu. autoHide boolean true Hide menu when mouse leaves trigger / menu elements. zIndex number | function 1 offset to add to zIndex className string Class to be appended to the root menu. classNames Object Default classname configuration to be able avoid conflicts in frameworks. Properties Name Type Default Description hover string context-menu-hover disabled string context-menu-disabled visible string context-menu-visible notSelectable string context-menu-not-selectable icon string context-menu-icon iconEdit string context-menu-icon-edit iconCut string context-menu-icon-cut iconCopy string context-menu-icon-copy iconPaste string context-menu-icon-paste iconDelete string context-menu-icon-delete iconAdd string context-menu-icon-add iconQuit string context-menu-icon-quit iconLoadingClass string context-menu-icon-loading animation Object Animation settings Properties Name Type Default Description duration number 50 show string 'slideDown' hide string 'slideUp' events Object Event callbacks. This is the trigger element, first argument is the event, and the second argumant ContextMenuData. Properties Name Type Description show function Called when contextmenu is shown. hide function Called when contextmenu is hidden. activated function Called when contextmenu is activated. callback ContextMenuItemCallback Global callback called then a ContextMenuItem is clicked. build ContextMenuBuildCallback false position position Callback to override the position of the context menu. The function is executed in the context of the trigger object. The first argument is a jQuery.Event. The second argument is the ContextMenuData object, which has a $menu property with the menu that needs to be positioned. The third and fourth arguments are x and y coordinates provided by the show event. The x and y may either be integers denoting the offset from the top left corner, undefined, or the string &quot;maintain&quot;. If the string &quot;maintain&quot; is provided, the current position of the $menu must be used. If the coordinates are undefined, appropriate coordinates must be determined. An example of how this can be achieved is provided with determinePosition. determinePosition determinePosition positionSubmenu positionSubmenu Callback tha positions a submenu Source: defaults/index.js, line 26 Methods determinePosition($menu) Determine the position for a root menu. Parameters: Name Type Description $menu JQuery Source: defaults/position.js, line 1 position(e, opt, x, y) Position the root menu. Parameters: Name Type Description e JQuery.Event opt ContextMenuData x number | string y number | string Source: defaults/position.js, line 28 positionSubmenu(e, $menu) Position a submenu. Parameters: Name Type Description e JQuery.Event $menu JQuery Source: defaults/position.js, line 78 × Search results Close "},"external-_jQuery.fn_.html":{"id":"external-_jQuery.fn_.html","title":"External: jQuery.fn","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery External: jQuery.fn jQuery.fn The jQuery plugin namespace. Source: jquery/contextMenuFunction.js, line 1 See: The jQuery Plugin Guide × Search results Close "},"external-_jQuery_.html":{"id":"external-_jQuery_.html","title":"External: jQuery","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery External: jQuery jQuery The jQuery namespace. Source: contextmenu.js, line 6 See: The jQuery Plugin Guide × Search results Close "},"tutorial-custom-command-types.html":{"id":"tutorial-custom-command-types.html","title":"Tutorial: Custom command types","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Custom command types Custom Command Types Besides the built-in command types custom handlers can be defined. The command generator must be placed in $.contextMenu.types. It is identified by the key given in that object. The generator function is executed in the context of the new command's &lt;li&gt; within the menu. item is the object passed at creation. Use this to pass values from your definition to the generator. opt is the current menu level, root is the menu's root-level opt (relevant for sub-menus only). A custom command type can be whatever you like it to be, it can behave how ever you want it to behave. Besides the keyboard interaction paradigm (up, down, tab, escape) key-events are passed on to the &lt;li&gt; which can be accessed via $(this).on('keydown', …); Note that you'll probably want to disable default action handling (click, pressing enter) in favor of the custom command's behavior. $.contextMenu.types.myType = function(item, opt, root) { $('&lt;span&gt;' + item.customName + '&lt;/span&gt;').appendTo(this); this.on('contextmenu:focus', function(e) { // setup some awesome stuff }).on('contextmenu:blur', function(e) { // tear down whatever you did }).on('keydown', function(e) { // some funky key handling, maybe? }); }; $.contextMenu({ selector: '.context-menu-custom', items: { label: {type: &quot;myType&quot;, customName: &quot;Foo Bar&quot;} } }); × Search results Close "},"tutorial-customize.html":{"id":"tutorial-customize.html","title":"Tutorial: Custom icons","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Custom icons Customize iconsYou can add icons to src/icons and run gulp build-icons. This will make the icons available for use in the contextmenu using the icon property. So for example the file checkmark.svg wil result in the CSS context-menu-icon-checkmark which you can use by using the icon option when defining a menu item. Is is also possible to just use FontAwesome icons, see the demo of FontAwesome. Examplevar items = { firstCommand: { name: &quot;Paste&quot;, icon: &quot;checkmark&quot; // Class context-menu-icon-checkmark is used on the menu item. This is generated from checkmark.svg } }Font-Awesome icons used from encharm/Font-Awesome-SVG-PNG. You can download more there if you like. Finally, you will need to re-build the CSS using sass, otherwise you may see mismatchings between the icon references. Use the command gulp css to re-build the CSS in the dist directory. The new CSS files will contain the icons you added. Customize CSSYou can use the _variables.scss to adjust variables on pretty much everything you want to change. × Search results Close "},"tutorial-events.html":{"id":"tutorial-events.html","title":"Tutorial: Contextmenu events","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Contextmenu events Events contextmenu prevcommand nextcommand contextmenu:hide contextmenu:focus contextmenu:blur keydown List of events that are triggered on the menu. You can manually trigger some events to control the menu. contextmenucontextmenu : Trigger context menu to be shown for a trigger object. Available on trigger object. The Event must be supplied with coordinates for the menu: {pageX: 123, pageY:123} $('.context-menu-one').first().trigger( $.Event('contextmenu', {pageX: 123, pageY: 123}) ); $('.context-menu-one').first().trigger(&quot;contextmenu&quot;);will invoke determinePosition to position the menu. prevcommandprevcommand : Select / highlight the previous possible command Available on context menu. opt.$menu.trigger(&quot;prevcommand&quot;);nextcommandnextcommand : Select / highlight the next possible command Available on context menu. opt.$menu.trigger(&quot;nextcommand&quot;);contextmenu:hidecontextmenu:hide : Hide the menu Available on context menu. opt.$menu.trigger(&quot;contextmenu:hide&quot;);contextmenu:focuscontextmenu:focus : React to a command item being focused Triggered on context menu item when mouse or keyboard interaction lead to a &quot;hover state&quot; for that command item. $(document.body).on(&quot;contextmenu:focus&quot;, &quot;.context-menu-item&quot;, function(e){ console.log(&quot;focus:&quot;, this); } );contextmenu:blurcontextmenu:blur : Available on each context menu item. Triggered on context menu item when mouse or keyboard interaction lead from a &quot;hover state&quot; to &quot;default state&quot; for that command item. $(document.body).on(&quot;contextmenu:blur&quot;, &quot;.context-menu-item&quot;, function(e){ console.log(&quot;blur:&quot;, this); } );keydownkeydown : Available on each context menu item. Triggered on context menu item when keyboard interaction could not be handled by jQuery.contextMenu. $(document.body).on(&quot;keydown&quot;, &quot;.context-menu-item&quot;, function(e){ console.log(&quot;key:&quot;, e.keyCode); } ); × Search results Close "},"tutorial-font-awesome.html":{"id":"tutorial-font-awesome.html","title":"Tutorial: Using Font-Awesome","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Using Font-Awesome Customize iconsIt is possible to use font-awesome icons if you like. You need to include the Font Awesome CSS in your application. That will enable you to use the icon classes to use those icons. Check out the demo Bring your own iconsIt is also possible to use your own SVG icons if you like, you can customize this by using the SASS files. × Search results Close "},"tutorial-html5-polyfill.html":{"id":"tutorial-html5-polyfill.html","title":"Tutorial: HTML5 polyfill","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery HTML5 polyfill HTML5 &lt;menu&gt; shiv/polyfill HTML5 &lt;menu&gt; import HTML5 &lt;menu&gt; shiv/polyfill HTML5 &lt;menu&gt; importconsidering the following HTML $.contextMenu.fromMenu($('#html5menu')) will return a proper items object. &lt;menu id=&quot;html5menu&quot; type=&quot;context&quot; style=&quot;display:none&quot;&gt; &lt;command label=&quot;rotate&quot; onclick=&quot;alert('rotate')&quot;&gt; &lt;command label=&quot;resize&quot; onclick=&quot;alert('resize')&quot;&gt; &lt;menu label=&quot;share&quot;&gt; &lt;command label=&quot;twitter&quot; onclick=&quot;alert('twitter')&quot;&gt; &lt;hr&gt; &lt;command label=&quot;facebook&quot; onclick=&quot;alert('facebook')&quot;&gt; &lt;/menu&gt; &lt;/menu&gt;$.contextMenu.fromMenu() will properly import (and thus handle) the following elements. Everything else is imported as {type: &quot;html&quot;} &lt;menu&gt; &lt;hr&gt; &lt;a&gt; &lt;command type=&quot;command|radio|checkbox&quot;&gt; (W3C Specification) &lt;menuitem type=&quot;command|radio|checkbox&quot;&gt; (Firefox) &lt;input type=&quot;text|radio|checkbox&quot;&gt; &lt;select&gt; &lt;textarea&gt; &lt;label for=&quot;someId&quot;&gt; &lt;label&gt; the text &lt;input|textarea|select&gt;The &lt;menu&gt; must be hidden but not removed, as all command events (clicks) are passed-thru to the original command element! Note: While the specs note &lt;option&gt;s to be renderd as regular commands, $.contextMenu will render an actual &lt;select&gt;. HTML5 &lt;menu&gt; shiv/polyfillEngaging the HTML5 polyfill (ignoring $.contextMenu if context menus are available natively): $(function(){ $.contextMenu(&quot;html5&quot;); });Engaging the HTML5 polyfill (ignoring browser native implementation): $(function(){ $.contextMenu(&quot;html5&quot;, true); }); × Search results Close "},"tutorial-input-helpers.html":{"id":"tutorial-input-helpers.html","title":"Tutorial: Input helpers","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Input helpers Helpers Import values for &lt;input&gt; Export values from &lt;input&gt; Import values for &lt;input&gt;To fill input commands with values from a map: {events: { hide: function(e, opt){ $.contextMenu.getInputValues(opt, {command1: &quot;foo&quot;, command2: &quot;bar&quot;}); } } }To fill input commands with values from data-attributes: {events: { hide: function(e, opt){ $.contextMenu.getInputValues(opt, this.data()); } } }Export values from &lt;input&gt;To fetch values from input commands: {events: { hide: function(e, opt){ var values = $.contextMenu.setInputValues(opt} } }To save values from input commands to data-attributes: {events: { hide: function(e, opt){ $.contextMenu.setInputValues(opt, this.data()); } } } × Search results Close "},"tutorial-items.html":{"id":"tutorial-items.html","title":"Tutorial: items","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery items currentMenu: itemsItems options.items name callback className icon disabled visible type events value selected radio options height items accesskey The items map contains the commands to list in the menu. Each command has a unique key identifying an item object. The value may either be an item (properties explained below), or a string (which will insert a separator, disregarding the string's content). It is also possible to define a seperator the same as an item, and use the type:cm_separator to define it. var items = { firstCommand: itemOptions, separator1: &quot;-----&quot;, separator2: { &quot;type&quot;: &quot;cm_separator&quot; }, command2: itemOptions }Since 2.3 it is also possible to use a promise as item, so you can build submenu's based on a snynchronous promis. Check out the demo using a promise for an example how to use this. The example uses jQuery deferred, but any promise should do. Promised can only be used in combination with the build option. options.itemsnameSpecify the human readable name of the command in the menu. This is used as the label for the option. name: string Examplevar items = { firstCommand: { name: &quot;Copy&quot; } }isHtmlNameWhen truthy, the defined name value is HTML. The value will be rendered using $.html() instead of $.text(). Note: Cannot be used with the accesskey option in the same item. isHtmlName: boolean Examplevar items = { firstCommand: { name: &quot;Copy &lt;span style='font-weight: bold'&gt;Text&lt;/span&gt;&quot;, isHtmlName: true } }callbackSpecifies the callback to execute if clicked on The Callback is executed in the context of the triggering object. The first argument is the key of the command. The second argument is the options object. The Callback may return false to prevent the menu from being hidden. If no callback and no default callback is specified, the item will not have an action callback: function(itemKey, opt, rootMenu, originalEvent) Examplevar items = { firstCommand: { name: &quot;Copy&quot;, callback: function(e, key, opt, root){ // Alert the key of the item and the trigger element's id. alert(&quot;Clicked on &quot; + itemKey + &quot; on element &quot; + opt.$trigger.id); // Do not close the menu after clicking an item return false; } } }classNameSpecifies additional classNames to add to the menu item. Seperate multiple classes by using spaces. className: string Examplevar items = { firstCommand: { name: &quot;Copy&quot;, className: 'contextmenu-item-custom contextmenu-item-custom__highlight' } }iconSpecifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like .context-menu-item.context-menu-icon-edit, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. icon: string or function(opt, $itemElement, itemKey, item) Examplevar items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $element, key, item, opt, root){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $element.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + opt.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } }disabled Specifies if the command is disabled (true) or enabled (false). May be a callback returning a boolean. The callback is executed in the context of the triggering object (so this inside the function refers to the element the context menu was shown for). The first argument is the key of the command. The second argument is the options object. disabled: boolean or function(itemKey, opt) Examplevar items = { firstCommand: { name: &quot;Copy&quot;, disabled: function(e, key, opt, root){ // Disable this item if the menu was triggered on a div if(opt.$trigger.nodeName === 'div'){ return true; } } } }visible Specifies if the command is visible (true) or not (false). May be a callback returning a boolean. The callback is executed in the context of the triggering object (so this inside the function refers to the element the context menu was shown for). The first argument is the key of the command. The second argument is the options object. visible: boolean or function(itemKey, opt) Examplevar items = { firstCommand: { name: &quot;Copy&quot;, visible: function(e, key, opt, root){ // Hide this item if the menu was triggered on a div if(opt.$trigger.nodeName === 'div'){ return false; } } } }typeSpecifies the type of the command. type: null, undefined, text, textarea, checkbox, radio, select, html default: null Value Description null, undefined , &quot;&quot; The command is a simple clickable item. &quot;text&quot; Makes the command an &lt;input&gt; of type text.The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. &quot;textarea&quot; Makes the command a &lt;textarea&gt;. The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. &quot;checkbox&quot; Makes the command an &lt;input&gt; of type checkbox. The name preceeded by the &lt;input&gt; are encapsulated in a &lt;label&gt;. The checkbox-element is moved to the icon space &quot;radio&quot; Makes the command an &lt;input&gt; of type radio. The name preceeded by the &lt;input&gt; are encapsulated in a &lt;label&gt;. The radio-element is moved to the icon space &quot;select&quot; Makes the command a &lt;select&gt;. The name followed by the &lt;select&gt; are encapsulated in a &lt;label&gt;. &quot;html&quot; Makes an non-command element. When you select type: 'html' add the html to the html property. So: { item: { type: 'html', html: '&lt;span&gt;html!&lt;/span&gt;' } }. You can also just use the item name with the isHtmlName property. Example$.contextMenu({ selector: 'span.context-menu', items: { name: { name: &quot;Text&quot;, type: 'text', value: &quot;Hello World&quot;, events: { keyup: function(e) { // add some fancy key handling here? window.console &amp;&amp; console.log('key: '+ e.keyCode); } } }, sep1: &quot;---------&quot;, // &lt;input type=&quot;checkbox&quot;&gt; yesno: { name: &quot;Boolean&quot;, type: 'checkbox', selected: true }, sep2: &quot;---------&quot;, // &lt;input type=&quot;radio&quot;&gt; radio1: { name: &quot;Radio1&quot;, type: 'radio', radio: 'radio', value: '1' }, radio2: { name: &quot;Radio2&quot;, type: 'radio', radio: 'radio', value: '2', selected: true }, sep3: &quot;---------&quot;, // &lt;select&gt; select: { name: &quot;Select&quot;, type: 'select', options: {1: 'one', 2: 'two', 3: 'three'}, selected: 2 }, // &lt;textarea&gt; area1: { name: &quot;Textarea with height&quot;, type: 'textarea', value: &quot;Hello World&quot;, height: 40 }, area2: { name: &quot;Textarea&quot;, type: 'textarea', value: &quot;Hello World&quot; }, sep4: &quot;---------&quot;, key: { name: &quot;Something Clickable&quot;, callback: $.noop } } });eventsEvents to register on &lt;input&gt; elements. The contents of the options object are passed to jQuery event.data. Only used with types text, textarea, radio, checkbox and select. events: object Example$.contextMenu({ selector: 'span.context-menu', events: { command1: { name: &quot;Foobar&quot;, type: &quot;text&quot;, events: { keyup: function(e){ alert(e.keyCode); alert(e.data.$trigger.attr(&quot;id&quot;)); } } } } });valueThe value of the &lt;input&gt; element. Only used with types text, textarea, radio. value: string Example$.contextMenu({ selector: 'span.context-menu', command1: { name: &quot;Foobar&quot;, type: &quot;text&quot;, value: &quot;default value&quot; } });selectedThe selected option of a select element and the checked property for checkbox and radio types. Only used with types select, checkbox, radio. selected: string or boolean Value Description boolean Use with checkbox and radio to check. string Use with select to select that option. Example$.contextMenu({ selector: 'span.context-menu', items: { // &lt;select&gt; select: { name: &quot;Select&quot;, type: 'select', options: {1: 'one', 2: 'two', 3: 'three'}, selected: &quot;2&quot; } } });radioSpecifies the group of the radio elements. Only used with type radio. radio: string Example$.contextMenu({ selector: 'span.context-menu', items: { // &lt;input type=&quot;radio&quot;&gt; radio1: { name: &quot;Radio1&quot;, type: 'radio', radio: 'radio', value: '1' }, radio2: { name: &quot;Radio2&quot;, type: 'radio', radio: 'radio', value: '2', selected: true } } });optionsSpecifies the &lt;option&gt; elements for the &lt;select&gt; element. Only used with type select. options: object Example$.contextMenu({ selector: 'span.context-menu', items: { // &lt;select&gt; select: { name: &quot;Select&quot;, type: 'select', options: {1: 'one', 2: 'two', 3: 'three'}, selected: &quot;2&quot; } } });heightThe height in pixel &lt;textarea&gt; element. If not specified, the height is defined by CSS. Only used with type textarea. height: int Example$.contextMenu({ selector: 'span.context-menu', items: { // &lt;select&gt; myTextarea: { name: &quot;Textarea&quot;, type: 'textarea', height: 200 } } });itemsCommands to show in a sub-menu. You can nest as many as you like. items: object Example$.contextMenu({ selector: 'span.context-menu', items: { // &lt;select&gt; myItemWithSubmenu: { name: &quot;Textarea&quot;, { items { mySubmenu { name: &quot;Command 1&quot; callback: function(e, key, opt, root){ alert(&quot;Clicked on &quot; + key); } } } } } } });accesskeyCharacter(s) to be used as accesskey. Considering a b c $.contextMenu will first try to use »a« as the accesskey, if already taken, it'll fall through to »b«. Words are reduced to the first character, so »hello world« is treated as »h w«. Note: Accesskeys are treated unique throughout one menu. This means an item in a sub-menu can't occupy the same accesskey as an item in the main menu. accesskey: string Example$.contextMenu({ selector: 'span.context-menu', accesskey: 'a' callback: function(itemKey, opt){ alert('I pressed a!'); } }); × Search results Close "},"tutorial-plugin-commands.html":{"id":"tutorial-plugin-commands.html","title":"Tutorial: Plugin commands","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery Plugin commands currentMenu: plugin-commandsPlugin commands Disable a contextMenu trigger Enable a contextMenu trigger Manually show a contextMenu Manually hide a contextMenu Unregister all contextMenus Disable a contextMenu triggerdisable contextMenu to be shown on specified trigger elements $(&quot;.some-selector&quot;).contextMenu(false);Enable a contextMenu triggerenable contextMenu to be shown on specified trigger elements $(&quot;.some-selector&quot;).contextMenu(true);Manually show a contextMenushow the contextMenu of the first element of the selector (position determined by determinePosition): $(&quot;.some-selector&quot;).contextMenu(); $(&quot;.some-selector&quot;).contextMenu({x: 123, y: 123});Manually hide a contextMenuhide the contextMenu of the first element of the selector: $(&quot;.some-selector&quot;).contextMenu(&quot;hide&quot;); Unregister contextMenuUnregister a specific contextMenuTo unregister / destroy a specific contextMenu: $.contextMenu( 'destroy', selector );selector expects the (string) selector that the contextMenu was registered to Unregister all contextMenusTo unregister / destroy all contextMenus: $.contextMenu( 'destroy' ); × Search results Close "},"tutorial-runtime-options.html":{"id":"tutorial-runtime-options.html","title":"Tutorial: runtime-options","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuSettings Tutorials Custom command typesCustom iconsContextmenu eventsUsing Font-AwesomeHTML5 polyfillInput helpersitemsPlugin commandsruntime-options Global ContextMenuItemTypessplitAccesskeyzindex Externals jQuery.fnjQuery runtime-options currentMenu: runtime-optionsRuntime options (opt) $node $input $label $menu $trigger callbacks commands inputs hasTypes ns The runtime options are passed to most callbacks on registration. This gives you the ability to access DOM elemnts and configuration dynamicly. One way of using these in in the general callback when an item is clicked. Example$.contextMenu({ selector: 'span.context-menu', items : { name: &quot;textfield&quot;, type: &quot;text&quot;, value: &quot;welcome!&quot; }, callback: function(e, key, opt, root){ // Alert the classes on the item that was clicked. alert(opt.$node.attr('class')); // Alert &quot;welcome!&quot; alert(opt.inputs[itemsKey].$input.val()); } });$selectedReference to the &lt;li&gt; command element. $selected: jQuery element $inputReference to the &lt;input&gt; or &lt;select&gt; of the command element. Only available with type &quot;text&quot;, &quot;textarea&quot;, &quot;checkbox&quot;, &quot;radio&quot; and &quot;select&quot;. $input: jQuery element $labelReference to the &lt;label&gt; of the command element. Only available with type &quot;text&quot;, &quot;textarea&quot;, &quot;checkbox&quot;, &quot;radio&quot; and &quot;select&quot;. $label: jQuery element $menuOr the menu element of the contextmenu or the &lt;ul&gt; sub-menu element when called inside a submenu. $node: jQuery element $triggerThe element triggering the menu. $trigger: jQuery element callbacksRegistered callbacks of all commands (including those of sub-menus). Warning: If you use the same keys for an item in any place, it will overwrite that callback here. callbacks: array commandsRegistered commands (including those of sub-menus). Warning: If you use the same keys for an item in any place, it will overwrite that command here. commands: array inputsRegistered commands of input-type (including those of sub-menus). Warning: If you use the same keys for an item in any place, it will overwrite that command here. Access a specific &lt;input&gt;: opt.inputs[key].$input inputs: jQuery element hasTypesflag denoting if the menu contains input elements. hasTypes: jQuery element nsThe namespace (including leading dot) all events for this contextMenu instance were registered under. ns: string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
