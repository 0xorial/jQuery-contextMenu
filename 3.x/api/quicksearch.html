<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes_ContextMenu.js.html":{"id":"classes_ContextMenu.js.html","title":"Source: classes/ContextMenu.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: classes/ContextMenu.js import ContextMenuOperations from './ContextMenuOperations'; import defaults from '../defaults'; import ContextMenuHtml5Builder from './ContextMenuHtml5Builder'; import ContextMenuEventHandler from './ContextMenuEventHandler'; export default class ContextMenu { /** * @constructor * @constructs ContextMenu * @classdesc The ContextMenu is the core class that manages contextmenu's. You can call this class directly and skip going through jQuery. * @class ContextMenu * * @example * // You can call this class directly and skip going through jQuery, although it still requires jQuery to run. * const manager = new ContextMenu(); * manager.execute(&quot;create&quot;, options); * * @property {ContextMenuOptions|Object} defaults * @property {ContextMenuEventHandler} handle * @property {ContextMenuOperations} operations * @property {Object&lt;string, ContextMenuData&gt;} menus * @property {number} counter - Internal counter to keep track of different menu's on the page. * @property {boolean} initialized - Flag the menu as initialized. */ constructor() { this.html5builder = new ContextMenuHtml5Builder(); this.defaults = defaults; this.handler = new ContextMenuEventHandler(); this.operations = new ContextMenuOperations(); this.namespaces = {}; this.initialized = false; this.menus = {}; this.counter = 0; } /** * @method execute * @memberOf ContextMenu * @instance * * @param {(string|ContextMenuOptions)} operation * @param {(string|ContextMenuOptions)} options * @return {ContextMenu} */ execute(operation, options) { const normalizedArguments = this.normalizeArguments(operation, options); operation = normalizedArguments.operation; options = normalizedArguments.options; switch (operation) { case 'update': // Updates visibility and such this.update(options); break; case 'create': // no selector no joy this.create(options); break; case 'destroy': this.destroy(options); break; case 'html5': this.html5(options); break; default: throw new Error('Unknown operation &quot;' + operation + '&quot;'); } return this; } /** * if &lt;menuitem&gt; is not handled by the browser, or options was a bool true, initialize $.contextMenu for them. * @param {ContextMenuOptions|boolean} options */ html5(options) { options = this.buildOptions(options); const menuItemSupport = ('contextMenu' in document.body &amp;&amp; 'HTMLMenuItemElement' in window); if (!menuItemSupport || (typeof options === 'boolean' &amp;&amp; options === true)) { $('menu[type=&quot;context&quot;]').each(function () { if (this.id) { $.contextMenu({ selector: '[contextmenu=' + this.id + ']', items: $.contextMenu.fromMenu(this) }); } }).css('display', 'none'); } } /** * Destroy the ContextMenu * @param {ContextMenuOptions} options */ destroy(options) { options = this.buildOptions(options); let $visibleMenu; if (options._hasContext) { // get proper options const context = options.context; Object.keys(this.menus).forEach((ns) =&gt; { let o = this.menus[ns]; if (!o) { return true; } // Is this menu equest to the context called from if (!$(context).is(o.selector)) { return true; } $visibleMenu = $('.context-menu-list').filter(':visible'); if ($visibleMenu.length &amp;&amp; $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) { $visibleMenu.trigger('contextmenu:hide', {force: true}); } if (this.menus[o.ns].$menu) { this.menus[o.ns].$menu.remove(); } delete this.menus[o.ns]; $(o.context).off(o.ns); return true; }); } else if (!options.selector) { $(document).off('.contextMenu .contextMenuAutoHide'); Object.keys(this.menus).forEach((ns) =&gt; { let o = this.menus[ns]; $(o.context).off(o.ns); }); this.namespaces = {}; this.menus = {}; this.counter = 0; this.initialized = false; $('#context-menu-layer, .context-menu-list').remove(); } else if (this.namespaces[options.selector]) { $visibleMenu = $('.context-menu-list').filter(':visible'); if ($visibleMenu.length &amp;&amp; $visibleMenu.data().contextMenuRoot.$trigger.is(options.selector)) { $visibleMenu.trigger('contextmenu:hide', {force: true}); } if (this.menus[this.namespaces[options.selector]].$menu) { this.menus[this.namespaces[options.selector]].$menu.remove(); } delete this.menus[this.namespaces[options.selector]]; $(document).off(this.namespaces[options.selector]); } this.handler.$currentTrigger = null; } /** * Create a ContextMenu * @param {ContextMenuOptions} options */ create(options) { options = this.buildOptions(options); if (!options.selector) { throw new Error('No selector specified'); } // make sure internal classes are not bound to if (options.selector.match(/.context-menu-(list|item|input)($|\\s)/)) { throw new Error('Cannot bind to selector &quot;' + options.selector + '&quot; as it contains a reserved className'); } if (!options.build &amp;&amp; (!options.items || $.isEmptyObject(options.items))) { throw new Error('No Items specified'); } this.counter++; options.ns = '.contextMenu' + this.counter; if (!options._hasContext) { this.namespaces[options.selector] = options.ns; } this.menus[options.ns] = options; // default to right click if (!options.trigger) { options.trigger = 'right'; } if (!this.initialized) { const itemClick = options.itemClickEvent === 'click' ? 'click.contextMenu' : 'mouseup.contextMenu'; const contextMenuItemObj = { // 'mouseup.contextMenu': this.handler.itemClick, // 'click.contextMenu': this.handler.itemClick, 'contextmenu:focus.contextMenu': this.handler.focusItem, 'contextmenu:blur.contextMenu': this.handler.blurItem, 'contextmenu.contextMenu': this.handler.abortevent, 'mouseenter.contextMenu': this.handler.itemMouseenter, 'mouseleave.contextMenu': this.handler.itemMouseleave }; contextMenuItemObj[itemClick] = this.handler.itemClick; // make sure item click is registered first $(document) .on({ 'contextmenu:hide.contextMenu': this.handler.hideMenu, 'prevcommand.contextMenu': this.handler.prevItem, 'nextcommand.contextMenu': this.handler.nextItem, 'contextmenu.contextMenu': this.handler.abortevent, 'mouseenter.contextMenu': this.handler.menuMouseenter, 'mouseleave.contextMenu': this.handler.menuMouseleave }, '.context-menu-list') .on('mouseup.contextMenu', '.context-menu-input', this.handler.inputClick) .on(contextMenuItemObj, '.context-menu-item'); this.initialized = true; } // engage native contextmenu event options.context .on('contextmenu' + options.ns, options.selector, options, this.handler.contextmenu); switch (options.trigger) { case 'hover': options.context .on('mouseenter' + options.ns, options.selector, options, this.handler.mouseenter) .on('mouseleave' + options.ns, options.selector, options, this.handler.mouseleave); break; case 'left': options.context.on('click' + options.ns, options.selector, options, this.handler.click); break; case 'touchstart': options.context.on('touchstart' + options.ns, options.selector, options, this.handler.click); break; /* default: // http://www.quirksmode.org/dom/events/contextmenu.html $document .on('mousedown' + o.ns, o.selector, o, this.handler.mousedown) .on('mouseup' + o.ns, o.selector, o, this.handler.mouseup); break; */ } // create menu if (!options.build) { this.operations.create(null, options); } } /** * Update the ContextMenu or all ContextMenu's * @param {ContextMenuOptions} options */ update(options) { options = this.buildOptions(options); if (options._hasContext) { this.operations.update(null, $(options.context).data('contextMenu'), $(options.context).data('contextMenuRoot')); } else { for (let menu in this.menus) { if (this.menus.hasOwnProperty(menu)) { this.operations.update(null, this.menus[menu]); } } } } /** * Build the options, by applying the Manager, defaults, user options and normalizing the context. * @param {ContextMenuOptions} userOptions * @return {ContextMenuOptions} */ buildOptions(userOptions) { if (typeof userOptions === 'string') { userOptions = {selector: userOptions}; } const options = $.extend(true, {manager: this}, this.defaults, userOptions); if (!options.context || !options.context.length) { options.context = $(document); options._hasContext = false; } else { // you never know what they throw at you... options.context = $(options.context).first(); options._hasContext = !$(options.context).is($(document)); } return options; } /** * @param {string|Object} operation * @param {string|Object|ContextMenuOptions} options * @returns {{operation: string, options: ContextMenuOptions}} */ normalizeArguments(operation, options) { if (typeof operation !== 'string') { options = operation; operation = 'create'; } if (typeof options === 'string') { options = {selector: options}; } else if (typeof options === 'undefined') { options = {}; } return {operation, options}; } /** * import values into `&lt;input&gt;` commands * * @method setInputValues * @memberOf ContextMenu * @instance * * @param {ContextMenuData} contextMenuData - {@link ContextMenuData} object * @param {Object} data - Values to set * @return {undefined} */ setInputValues(contextMenuData, data) { if (typeof data === 'undefined') { data = {}; } $.each(contextMenuData.inputs, function (key, item) { switch (item.type) { case 'text': case 'textarea': item.value = data[key] || ''; break; case 'checkbox': item.selected = !!data[key]; break; case 'radio': item.selected = (data[item.radio] || '') === item.value; break; case 'select': item.selected = data[key] || ''; break; } }); } /** * export values from `&lt;input&gt;` commands * * @method getInputValues * @memberOf ContextMenu * @instance * * @param {ContextMenuData} contextMenuData - {@link ContextMenuData} object * @param {Object} data - Values object * @return {Object} - Values of input elements */ getInputValues(contextMenuData, data) { if (typeof data === 'undefined') { data = {}; } $.each(contextMenuData.inputs, function (key, item) { switch (item.type) { case 'text': case 'textarea': case 'select': data[key] = item.$input.val(); break; case 'checkbox': data[key] = item.$input.prop('checked'); break; case 'radio': if (item.$input.prop('checked')) { data[item.radio] = item.value; } break; } }); return data; } } × Search results Close "},"defaults_interfaces.js.html":{"id":"defaults_interfaces.js.html","title":"Source: defaults/interfaces.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: defaults/interfaces.js /** * Specifies the icon class to set for the item. * * When using a string icons must be defined in CSS with selectors like `.context-menu-item.context-menu-icon-edit`, where edit is the icon class specified. * * When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. * * @example * var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, currentMenuData, rootMenuData){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + currentMenuData.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } * * @callback ContextMenuIconCallback * @param {ContextMenuEvent|JQuery.Event} e, * @param {JQuery} $t * @param {string} key * @param {ContextMenuItem} item * @param {ContextMenuData} currentMenuData * @param {ContextMenuData} rootMenuData */ /** * Specifies the icon class to set for the item. * * When using a string icons must be defined in CSS with selectors like `.context-menu-item.context-menu-icon-edit`, where edit is the icon class specified. * * When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. * * @example * var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, currentMenuData, rootMenuData){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + currentMenuData.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } * * @callback ContextMenuIconCallback * @param {ContextMenuEvent|JQuery.Event} e, * @param {JQuery} $t * @param {string} key * @param {ContextMenuItem} item * @param {ContextMenuData} currentMenuData * @param {ContextMenuData} rootMenuData */ /** * The Callback is executed in the context of the triggering object. * * @callback ContextMenuItemCallback * @param {JQuery.Event} e - Event that trigged the menu. * @param {string} key - Key of the menu item. * @param {ContextMenuData} currentMenuData - Data of the (sub)menu in which the item resides. * @param {ContextMenuData} rootMenuData - Data of the root menu in which the item resides. Might be the same as `currentMenuData` if triggered in the menu root. * @return {boolean} */ /** * @callback ContextMenuBuildCallback * @param {JQuery.Event} e - Event that trigged the menu. * @param {JQuery} $currentTrigger - Element that trigged the menu. * @return {Object.&lt;string,ContextMenuItem&gt;} */ /** * Runs in the scope of the `&lt;li&gt;` of the contextmenu. * @callback ContextMenuItemTypeCallback * @param {JQuery.Event} e - Event that trigged the menu. * @param {ContextMenuItem} item - Menu item * @param {ContextMenuData} currentMenuData - Data of the (sub)menu in which the item resides. * @param {ContextMenuData} rootMenuData - Data of the root menu in which the item resides. Might be the same as `currentMenuData` if triggered in the menu root. */ × Search results Close "},"defaults_index.js.html":{"id":"defaults_index.js.html","title":"Source: defaults/index.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: defaults/index.js import {determinePosition, positionSubmenu, position} from './position'; /** * @class ContextMenuData * @augments ContextMenuOptions * @instance * @interface * * @property {JQuery} $menu - The menu element for this menu part. Eg. the root menu, or a single submenu. * @property {JQuery} $layer - The opened layer when the menu is opened. * @property {JQuery} $node - The menu node. * @property {JQuery} $trigger - The element that triggered opening the menu. * @property {JQuery} $selected - Reference to the `&lt;li&gt;` command element. * @property {JQuery} $input - Reference to the `&lt;input&gt;` or `&lt;select&gt;` of the command element. * @property {JQuery} $label - Reference to the `&lt;input&gt;` or `&lt;select&gt;` of the command element. * @property {string} ns - The namespace (including leading dot) all events for this contextMenu instance were registered under. * @property {ContextMenu} manager - The contextmenu manager instance. * @property {JQuery|jQuery|null} $selected - Currently selected menu item, or input inside menu item. * @property {?boolean} hasTypes - The menu has ContextMenuItem which are of a selectable type. * @property {?boolean} isInput - We are currently originating events from an input. * @property {Object&lt;string, ContextMenuItem&gt;} inputs - Inputs defined in the menu. * @property {Object&lt;string, ContextMenuItemTypeCallback&gt;} types - Custom ContextMenuItemTypes, key is the {@link ContextMenuItem} type property, value is a {@link ContextMenuItemTypeCallback} callback. * * @property {boolean} hovering Currently hovering, root menu only. */ /** * @class ContextMenuOptions * @instance * @interface * @classdesc ## Register new contextMenu To register a new contextMenu: ```javascript $.contextMenu( contextMenuOptions ); ``` ## Update contextMenu state It is possible to refresh the state of the contextmenu [disabled](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#disabled), [visibility](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#visible), [icons](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#icon) and [input values](https://swisnl.github.io/jQuery-contextMenu/docs/items.html#type) through the `update` command. This will reevaluate any custom callbacks. ```javascript $('.context-menu-one').contextMenu('update'); // update single menu $.contextMenu('update') // update all open menus ``` * @property {null|string} selector - Selector on which the contextMenu triggers. * @property {Object.&lt;string, ContextMenuItem&gt;} items - Object with items to be listed in contextMenu. See {@link ContextMenuItem} for a full documentation on how to build your menu items. * @property {JQuery.Selector|DOMElement} [appendTo=document.body] - Specifies the selector `string` or `DOMElement` the generated menu is to be appended to. * @property {('right'|'left'|'hover'|'touchstart'|'none')} trigger=left - Method to trigger context menu [&quot;right&quot;, &quot;left&quot;, &quot;hover&quot;, &quot;touchstart&quot;, &quot;none&quot;]. * @property {?string} itemClickEvent - Allows the selection of the click event instead of the mouseup event to handle the user mouse interaction with the contexMenu. The default event is `mouseup`. Set the option to `&quot;click&quot;` to change to the `click` event. This option is global: the first contexMenu registered sets it. To change it afterwards all the contextMenu have to be unregistered with `$.contextMenu( 'destroy' );` before the change has effect again. * @property {boolean} hideOnSecondTrigger=false - Flag denoting if a second trigger should close the menu, as long as the trigger happened on one of the trigger-element's child nodes. This overrides the reposition option. * @property {boolean} selectableSubMenu=false - Ability to select ContextMenuItem containing a submenu. * @property {boolean} reposition=true - flag denoting if a second trigger should simply move (`true`) or rebuild (`false`) an open menu as long as the trigger happened on one of the trigger-element's child nodes * @property {number} delay=200 - ms to wait before showing a hover-triggered context menu. * @property {boolean} autoHide=true - Hide menu when mouse leaves trigger / menu elements. * @property {number|Function} zIndex=1 - offset to add to zIndex * @property {string} className - Class to be appended to the root menu. * @property {Object} classNames - Default classname configuration to be able avoid conflicts in frameworks. * @property {string} classNames.hover=context-menu-hover * @property {string} classNames.disabled=context-menu-disabled * @property {string} classNames.visible=context-menu-visible * @property {string} classNames.notSelectable=context-menu-not-selectable * @property {string} classNames.icon=context-menu-icon * @property {string} classNames.iconEdit=context-menu-icon-edit * @property {string} classNames.iconCut=context-menu-icon-cut * @property {string} classNames.iconCopy=context-menu-icon-copy * @property {string} classNames.iconPaste=context-menu-icon-paste * @property {string} classNames.iconDelete=context-menu-icon-delete * @property {string} classNames.iconAdd=context-menu-icon-add * @property {string} classNames.iconQuit=context-menu-icon-quit * @property {string} classNames.iconLoadingClass=context-menu-icon-loading * @property {Object} animation - Animation settings * @property {number} animation.duration=50 * @property {string} animation.show='slideDown' * @property {string} animation.hide='slideUp' * @property {Object} events - Event callbacks. This is the trigger element, first argument is the event, and the second argumant {@link ContextMenuData}. * @property {Function} events.show - Called when contextmenu is shown. * @property {Function} events.hide - Called when contextmenu is hidden. * @property {Function} events.activated - Called when contextmenu is activated. * @property {ContextMenuItemCallback} callback - Global callback called then a {@link ContextMenuItem} is clicked. * @property {ContextMenuBuildCallback} build=false * @property {(position)} position - Callback to override the position of the context menu. The function is executed in the context of the trigger object. The first argument is a jQuery.Event. The second argument is the {@link ContextMenuData} object, which has a `$menu` property with the menu that needs to be positioned. The third and fourth arguments are `x` and `y` coordinates provided by the show event. The `x` and `y` may either be integers denoting the offset from the top left corner, undefined, or the string &quot;maintain&quot;. If the string &quot;maintain&quot; is provided, the current position of the `$menu` must be used. If the coordinates are `undefined`, appropriate coordinates must be determined. An example of how this can be achieved is provided with {@link determinePosition}. * @property {(determinePosition)} determinePosition * @property {(positionSubmenu)} positionSubmenu - Callback tha positions a submenu * @property {boolean} _hasContext - Set to true if the call was done from an element. */ export default { selector: null, // where to append the menu to appendTo: null, // method to trigger context menu [&quot;right&quot;, &quot;left&quot;, &quot;hover&quot;] trigger: 'right', // hide menu when mouse leaves trigger / menu elements autoHide: false, // ms to wait before showing a hover-triggered context menu delay: 200, // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu // as long as the trigger happened on one of the trigger-element's child nodes reposition: true, // Flag denoting if a second trigger should close the menu, as long as // the trigger happened on one of the trigger-element's child nodes. // This overrides the reposition option. hideOnSecondTrigger: false, // ability to select submenu selectableSubMenu: false, className: '', // Default classname configuration to be able avoid conflicts in frameworks classNames: { hover: 'context-menu-hover', // Item hover disabled: 'context-menu-disabled', // Item disabled visible: 'context-menu-visible', // Item visible notSelectable: 'context-menu-not-selectable', // Item not selectable icon: 'context-menu-icon', iconEdit: 'context-menu-icon-edit', iconCut: 'context-menu-icon-cut', iconCopy: 'context-menu-icon-copy', iconPaste: 'context-menu-icon-paste', iconDelete: 'context-menu-icon-delete', iconAdd: 'context-menu-icon-add', iconQuit: 'context-menu-icon-quit', iconLoadingClass: 'context-menu-icon-loading' }, // offset to add to zIndex zIndex: 1, // show hide animation settings animation: { duration: 50, show: 'slideDown', hide: 'slideUp' }, // events events: { show: $.noop, hide: $.noop, activated: $.noop }, // default callback callback: null, // list of contextMenu items items: {}, // Build callback for creating a menu dynamicly build: false, types: {}, // determine position to show menu at determinePosition, // position menu position, // position the sub-menu positionSubmenu }; × Search results Close "},"defaults_position.js.html":{"id":"defaults_position.js.html","title":"Source: defaults/position.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: defaults/position.js /** * Determine the position for a root menu. * @memberOf ContextMenuOptions * @function ContextMenuOptions#determinePosition * @param {(JQuery)} $menu */ export function determinePosition($menu) { // position to the lower middle of the trigger element if ($.ui &amp;&amp; $.ui.position) { // .position() is provided as a jQuery UI utility // (...and it won't work on hidden elements) $menu.css('display', 'block').position({ my: 'center top', at: 'center bottom', of: this, offset: '0 5', collision: 'fit' }).css('display', 'none'); } else { // determine contextMenu position const offset = this.offset(); offset.top += this.outerHeight(); offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2; $menu.css(offset); } } /** * Position the root menu. * @memberOf ContextMenuOptions * @function ContextMenuOptions#position * @param {JQuery.Event} e * @param {ContextMenuData} currentMenuData * @param {(number|string)} x * @param {(number|string)} y */ export function position(e, currentMenuData, x, y) { const $window = $(window); let offset; // determine contextMenu position if (!x &amp;&amp; !y) { currentMenuData.determinePosition.call(this, currentMenuData.$menu); return; } else if (x === 'maintain' &amp;&amp; y === 'maintain') { // x and y must not be changed (after re-show on command click) offset = currentMenuData.$menu.position(); } else { // x and y are given (by mouse event) const offsetParentOffset = currentMenuData.$menu.offsetParent().offset(); offset = {top: y - offsetParentOffset.top, left: x - offsetParentOffset.left}; } // correct offset if viewport demands it const bottom = $window.scrollTop() + $window.height(); const right = $window.scrollLeft() + $window.width(); const height = currentMenuData.$menu.outerHeight(); const width = currentMenuData.$menu.outerWidth(); if (offset.top + height &gt; bottom) { offset.top -= height; } if (offset.top &lt; 0) { offset.top = 0; } if (offset.left + width &gt; right) { offset.left -= width; } if (offset.left &lt; 0) { offset.left = 0; } currentMenuData.$menu.css(offset); } /** * Position a submenu. * @memberOf ContextMenuOptions * @function ContextMenuOptions#positionSubmenu * @param {JQuery.Event} e * @param {JQuery} $menu */ // position the sub-menu export function positionSubmenu(e, $menu) { if (typeof $menu === 'undefined') { // When user hovers over item (which has sub items) handle.focusItem will call this. // but the submenu does not exist yet if ContextMenuData.items is a promise. just return, will // call positionSubmenu after promise is completed. return; } if ($.ui &amp;&amp; $.ui.position) { // .position() is provided as a jQuery UI utility // (...and it won't work on hidden elements) $menu.css('display', 'block').position({ my: 'left top-5', at: 'right top', of: this, collision: 'flipfit fit' }).css('display', ''); } else { // determine contextMenu position const offset = { top: -9, left: this.outerWidth() - 5 }; $menu.css(offset); } } × Search results Close "},"classes_ContextMenuEventHandler.js.html":{"id":"classes_ContextMenuEventHandler.js.html","title":"Source: classes/ContextMenuEventHandler.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: classes/ContextMenuEventHandler.js import defaults from '../defaults'; /** * @typedef {jQuery.Event} ContextMenuEvent * @augments jQuery.Event * @property {ContextMenuData} data */ export default class ContextMenuEventHandler { /** * @constructs ContextMenuEventHandler * @constructor * @property {?JQuery} $currentTrigger * @property {Object} hoveract */ constructor() { this.$currentTrigger = null; this.hoveract = {}; } /** * Helper to abort an event * * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ abortevent(e) { e.preventDefault(); e.stopImmediatePropagation(); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ contextmenu(e) { const $this = $(e.currentTarget); if (!e.data) { throw new Error('No data attached'); } // disable actual context-menu if we are using the right mouse button as the trigger if (e.data.trigger === 'right') { e.preventDefault(); e.stopImmediatePropagation(); } // abort native-triggered events unless we're triggering on right click if ((e.data.trigger !== 'right' &amp;&amp; e.data.trigger !== 'demand') &amp;&amp; e.originalEvent) { return; } // Let the current contextmenu decide if it should show or not based on its own trigger settings if (typeof e.mouseButton !== 'undefined') { if (!(e.data.trigger === 'left' &amp;&amp; e.mouseButton === 0) &amp;&amp; !(e.data.trigger === 'right' &amp;&amp; e.mouseButton === 2)) { // Mouse click is not valid. return; } } // abort event if menu is visible for this trigger if ($this.hasClass('context-menu-active')) { return; } if (!$this.hasClass('context-menu-disabled')) { // theoretically need to fire a show event at &lt;menu&gt; // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus // var evt = jQuery.Event(&quot;show&quot;, { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this }); // e.data.$menu.trigger(evt); e.data.manager.handler.$currentTrigger = $this; if (e.data.build) { const built = e.data.build(e, $this); // abort if build() returned false if (built === false) { return; } // dynamically build menu on invocation e.data = $.extend(true, {}, defaults, e.data, built || {}); // abort if there are no items to display if (!e.data.items || $.isEmptyObject(e.data.items)) { // Note: jQuery captures and ignores errors from event handlers if (window.console) { (console.error || console.log).call(console, 'No items specified to show in contextMenu'); } throw new Error('No Items specified'); } // backreference for custom command type creation e.data.$trigger = e.data.manager.handler.$currentTrigger; e.data.manager.operations.create(e, e.data); } let showMenu = false; for (let item in e.data.items) { if (e.data.items.hasOwnProperty(item)) { let visible; if ($.isFunction(e.data.items[item].visible)) { visible = e.data.items[item].visible.call($this, e, item, e.data, e.data); } else if (typeof e.data.items[item] !== 'undefined' &amp;&amp; e.data.items[item].visible) { visible = e.data.items[item].visible === true; } else { visible = true; } if (visible) { showMenu = true; } } } if (showMenu) { // show menu e.data.manager.operations.show.call($this, e, e.data, e.pageX, e.pageY); } } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ click(e) { e.preventDefault(); e.stopImmediatePropagation(); $(this).trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY, originalEvent: e})); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mousedown(e) { // register mouse down const $this = $(this); // hide any previous menus if (e.data.manager.handler.$currentTrigger &amp;&amp; e.data.manager.handler.$currentTrigger.length &amp;&amp; !e.data.manager.handler.$currentTrigger.is($this)) { e.data.manager.handler.$currentTrigger.data('contextMenu').$menu.trigger($.Event('contextmenu', {data: e.data, originalEvent: e})); } // activate on right click if (e.button === 2) { e.data.manager.handler.$currentTrigger = $this.data('contextMenuActive', true); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mouseup(e) { // show menu const $this = $(this); if ($this.data('contextMenuActive') &amp;&amp; e.data.manager.handler.$currentTrigger &amp;&amp; e.data.manager.handler.$currentTrigger.length &amp;&amp; e.data.manager.handler.$currentTrigger.is($this) &amp;&amp; !$this.hasClass('context-menu-disabled')) { e.preventDefault(); e.stopImmediatePropagation(); e.data.manager.handler.$currentTrigger = $this; $this.trigger($.Event('contextmenu', {data: e.data, pageX: e.pageX, pageY: e.pageY, originalEvent: e})); } $this.removeData('contextMenuActive'); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mouseenter(e) { const $this = $(this); const $related = $(e.relatedTarget); const $document = $(document); // abort if we're coming from a menu if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) { return; } // abort if a menu is shown if (e.data.manager.handler.$currentTrigger &amp;&amp; e.data.manager.handler.$currentTrigger.length) { return; } e.data.manager.handler.hoveract.pageX = e.pageX; e.data.manager.handler.hoveract.pageY = e.pageY; e.data.manager.handler.hoveract.data = e.data; $document.on('mousemove.contextMenuShow', e.data.manager.handler.mousemove); e.data.manager.handler.hoveract.timer = setTimeout(function () { e.data.manager.handler.hoveract.timer = null; $document.off('mousemove.contextMenuShow'); e.data.manager.handler.$currentTrigger = $this; $this.trigger($.Event('contextmenu', { data: e.data.manager.handler.hoveract.data, pageX: e.data.manager.handler.hoveract.pageX, pageY: e.data.manager.handler.hoveract.pageY })); }, e.data.delay); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mousemove(e) { e.data.manager.handler.hoveract.pageX = e.pageX; e.data.manager.handler.hoveract.pageY = e.pageY; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ mouseleave(e) { // abort if we're leaving for a menu const $related = $(e.relatedTarget); if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) { return; } try { clearTimeout(e.data.manager.handler.hoveract.timer); } catch (e) { } e.data.manager.handler.hoveract.timer = null; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ layerClick(e) { let $this = $(this); let root = $this.data('contextMenuRoot'); if (root === null || typeof root === 'undefined') { throw new Error('No ContextMenuData found'); } let button = e.button; let x = e.pageX; let y = e.pageY; let target; let offset; e.preventDefault(); setTimeout(function () { let $window = $(window); let triggerAction = ((root.trigger === 'left' &amp;&amp; button === 0) || (root.trigger === 'right' &amp;&amp; button === 2)); // find the element that would've been clicked, wasn't the layer in the way if (document.elementFromPoint &amp;&amp; root.$layer) { root.$layer.hide(); target = document.elementFromPoint(x - $window.scrollLeft(), y - $window.scrollTop()); // also need to try and focus this element if we're in a contenteditable area, // as the layer will prevent the browser mouse action we want if (target.isContentEditable) { const range = document.createRange(); const sel = window.getSelection(); range.selectNode(target); range.collapse(true); sel.removeAllRanges(); sel.addRange(range); } $(target).trigger(e); root.$layer.show(); } if (root.hideOnSecondTrigger &amp;&amp; triggerAction &amp;&amp; root.$menu !== null &amp;&amp; typeof root.$menu !== 'undefined') { root.$menu.trigger('contextmenu:hide', {data: root, originalEvent: e}); return; } if (root.reposition &amp;&amp; triggerAction) { if (document.elementFromPoint) { if (root.$trigger.is(target)) { root.position.call(root.$trigger, e, root, x, y); return; } } else { offset = root.$trigger.offset(); const $window = $(window); // while this looks kinda awful, it's the best way to avoid // unnecessarily calculating any positions offset.top += $window.scrollTop(); if (offset.top &lt;= e.pageY) { offset.left += $window.scrollLeft(); if (offset.left &lt;= e.pageX) { offset.bottom = offset.top + root.$trigger.outerHeight(); if (offset.bottom &gt;= e.pageY) { offset.right = offset.left + root.$trigger.outerWidth(); if (offset.right &gt;= e.pageX) { // reposition root.position.call(root.$trigger, e, root, x, y); return; } } } } } } if (target &amp;&amp; triggerAction) { root.$trigger.one('contextmenu:hidden', function () { $(target).contextMenu({x: x, y: y, button: button, originalEvent: e}); }); } if (root.$menu !== null &amp;&amp; typeof root.$menu !== 'undefined') { root.$menu.trigger('contextmenu:hide', {data: root, originalEvent: e}); } }, 50); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e * @param {ContextMenuItem} currentMenuData */ keyStop(e, currentMenuData) { if (!currentMenuData.isInput) { e.preventDefault(); } e.stopPropagation(); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ key(e) { let rootMenuData = {}; // Only get the data from this.$currentTrigger if it exists if (e.data.manager.handler.$currentTrigger) { rootMenuData = e.data.manager.handler.$currentTrigger.data('contextMenu') || {}; } // If the trigger happen on a element that are above the contextmenu do this if (typeof rootMenuData.zIndex === 'undefined') { rootMenuData.zIndex = 0; } const getZIndexOfTriggerTarget = function (target) { if (target.style.zIndex !== '') { return target.style.zIndex; } else { if (target.offsetParent !== null &amp;&amp; typeof target.offsetParent !== 'undefined') { return getZIndexOfTriggerTarget(target.offsetParent); } else if (target.parentElement !== null &amp;&amp; typeof target.parentElement !== 'undefined') { return getZIndexOfTriggerTarget(target.parentElement); } } }; let targetZIndex = getZIndexOfTriggerTarget(e.target); // If targetZIndex is heigher then rootMenuData.zIndex dont progress any futher. // This is used to make sure that if you are using a dialog with a input / textarea / contenteditable div // and its above the contextmenu it wont steal keys events if (rootMenuData.$menu &amp;&amp; parseInt(targetZIndex, 10) &gt; parseInt(rootMenuData.$menu.css('zIndex'), 10)) { return; } switch (e.keyCode) { case 9: case 38: // up e.data.manager.handler.keyStop(e, rootMenuData); // if keyCode is [38 (up)] or [9 (tab) with shift] if (rootMenuData.isInput) { if (e.keyCode === 9 &amp;&amp; e.shiftKey) { e.preventDefault(); if (rootMenuData.$selected) { rootMenuData.$selected.find('input, textarea, select').blur(); } if (rootMenuData.$menu !== null &amp;&amp; typeof rootMenuData.$menu !== 'undefined') { rootMenuData.$menu.trigger('prevcommand', {data: rootMenuData, originalEvent: e}); } return; } else if (e.keyCode === 38 &amp;&amp; rootMenuData.$selected.find('input, textarea, select').prop('type') === 'checkbox') { // checkboxes don't capture this key e.preventDefault(); return; } } else if (e.keyCode !== 9 || e.shiftKey) { if (rootMenuData.$menu !== null &amp;&amp; typeof rootMenuData.$menu !== 'undefined') { rootMenuData.$menu.trigger('prevcommand', {data: rootMenuData, originalEvent: e}); } return; } break; // omitting break; // case 9: // tab - reached through omitted break; case 40: // down e.data.manager.handler.keyStop(e, rootMenuData); if (rootMenuData.isInput) { if (e.keyCode === 9) { e.preventDefault(); if (rootMenuData.$selected) { rootMenuData.$selected.find('input, textarea, select').blur(); } if (rootMenuData.$menu !== null &amp;&amp; typeof rootMenuData.$menu !== 'undefined') { rootMenuData.$menu.trigger('nextcommand', {data: rootMenuData, originalEvent: e}); } return; } else if (e.keyCode === 40 &amp;&amp; rootMenuData.$selected.find('input, textarea, select').prop('type') === 'checkbox') { // checkboxes don't capture this key e.preventDefault(); return; } } else { if (rootMenuData.$menu !== null &amp;&amp; typeof rootMenuData.$menu !== 'undefined') { rootMenuData.$menu.trigger('nextcommand', {data: rootMenuData, originalEvent: e}); } return; } break; case 37: // left e.data.manager.handler.keyStop(e, rootMenuData); if (rootMenuData.isInput || !rootMenuData.$selected || !rootMenuData.$selected.length) { break; } if (!rootMenuData.$selected.parent().hasClass('context-menu-root')) { const $parent = rootMenuData.$selected.parent().parent(); rootMenuData.$selected.trigger('contextmenu:blur', {data: rootMenuData, originalEvent: e}); rootMenuData.$selected = $parent; return; } break; case 39: // right e.data.manager.handler.keyStop(e, rootMenuData); if (rootMenuData.isInput || !rootMenuData.$selected || !rootMenuData.$selected.length) { break; } const itemdata = rootMenuData.$selected.data('contextMenu') || {}; if (itemdata.$menu &amp;&amp; rootMenuData.$selected.hasClass('context-menu-submenu')) { rootMenuData.$selected = null; itemdata.$selected = null; itemdata.$menu.trigger('nextcommand', {data: itemdata, originalEvent: e}); return; } break; case 35: // end case 36: // home if (rootMenuData.$selected &amp;&amp; rootMenuData.$selected.find('input, textarea, select').length) { break; } else { ((rootMenuData.$selected &amp;&amp; rootMenuData.$selected.parent()) || rootMenuData.$menu) .children(':not(.' + rootMenuData.classNames.disabled + ', .' + rootMenuData.classNames.notSelectable + ')')[e.keyCode === 36 ? 'first' : 'last']() .trigger('contextmenu:focus', {data: rootMenuData, originalEvent: e}); e.preventDefault(); break; } case 13: // enter e.data.manager.handler.keyStop(e, rootMenuData); if (rootMenuData.isInput) { if (rootMenuData.$selected &amp;&amp; !rootMenuData.$selected.is('textarea, select')) { e.preventDefault(); return; } break; } if (typeof rootMenuData.$selected !== 'undefined' &amp;&amp; rootMenuData.$selected !== null) { rootMenuData.$selected.trigger('mouseup', {data: rootMenuData, originalEvent: e}); } return; case 32: // space case 33: // page up case 34: // page down // prevent browser from scrolling down while menu is visible e.data.manager.handler.keyStop(e, rootMenuData); return; case 27: // esc e.data.manager.handler.keyStop(e, rootMenuData); if (rootMenuData.$menu !== null &amp;&amp; typeof rootMenuData.$menu !== 'undefined') { rootMenuData.$menu.trigger('contextmenu:hide', {data: rootMenuData, originalEvent: e}); } return; default: // 0-9, a-z const k = (String.fromCharCode(e.keyCode)).toUpperCase(); if (rootMenuData.accesskeys &amp;&amp; rootMenuData.accesskeys[k]) { // according to the specs accesskeys must be invoked immediately rootMenuData.accesskeys[k].$node.trigger(rootMenuData.accesskeys[k].$menu ? 'contextmenu:focus' : 'mouseup', {data: rootMenuData, originalEvent: e}); return; } break; } // pass event to selected item, // stop propagation to avoid endless recursion e.stopPropagation(); if (typeof rootMenuData.$selected !== 'undefined' &amp;&amp; rootMenuData.$selected !== null) { rootMenuData.$selected.trigger(e); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ prevItem(e) { e.stopPropagation(); let currentMenuData = $(this).data('contextMenu') || {}; const rootMenuData = $(this).data('contextMenuRoot') || {}; // obtain currently selected menu if (currentMenuData.$selected) { const $s = currentMenuData.$selected; currentMenuData = currentMenuData.$selected.parent().data('contextMenu') || {}; currentMenuData.$selected = $s; } const $children = currentMenuData.$menu.children(); let $prev = !currentMenuData.$selected || !currentMenuData.$selected.prev().length ? $children.last() : currentMenuData.$selected.prev(); const $round = $prev; // skip disabled or hidden elements while ($prev.hasClass(rootMenuData.classNames.disabled) || $prev.hasClass(rootMenuData.classNames.notSelectable) || $prev.is(':hidden')) { if ($prev.prev().length) { $prev = $prev.prev(); } else { $prev = $children.last(); } if ($prev.is($round)) { // break endless loop return; } } // leave current if (currentMenuData.$selected) { rootMenuData.manager.handler.itemMouseleave.call(currentMenuData.$selected.get(0), e); } // activate next rootMenuData.manager.handler.itemMouseenter.call($prev.get(0), e); // focus input const $input = $prev.find('input, textarea, select'); if ($input.length) { $input.focus(); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ nextItem(e) { e.stopPropagation(); let currentMenuData = $(this).data('contextMenu') || {}; let rootMenuData = $(this).data('contextMenuRoot') || {}; // obtain currently selected menu if (currentMenuData.$selected) { const $s = currentMenuData.$selected; currentMenuData = currentMenuData.$selected.parent().data('contextMenu') || {}; currentMenuData.$selected = $s; } const $children = currentMenuData.$menu.children(); let $next = !currentMenuData.$selected || !currentMenuData.$selected.next().length ? $children.first() : currentMenuData.$selected.next(); const $round = $next; // skip disabled while ($next.hasClass(rootMenuData.classNames.disabled) || $next.hasClass(rootMenuData.classNames.notSelectable) || $next.is(':hidden')) { if ($next.next().length) { $next = $next.next(); } else { $next = $children.first(); } if ($next.is($round)) { // break endless loop return; } } // leave current if (currentMenuData.$selected) { rootMenuData.manager.handler.itemMouseleave.call(currentMenuData.$selected.get(0), e); } // activate next rootMenuData.manager.handler.itemMouseenter.call($next.get(0), e); // focus input const $input = $next.find('input, textarea, select'); if ($input.length) { $input.focus(); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ focusInput(e) { let $this = $(this).closest('.context-menu-item'); let data = $this.data(); let currentMenuData = data.contextMenu; let rootMenuData = data.contextMenuRoot; rootMenuData.$selected = currentMenuData.$selected = $this; rootMenuData.isInput = currentMenuData.isInput = true; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ blurInput(e) { let $this = $(this).closest('.context-menu-item'); let data = $this.data(); let currentMenuData = data.contextMenu; let rootMenuData = data.contextMenuRoot; rootMenuData.isInput = currentMenuData.isInput = false; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ menuMouseenter(e) { let root = $(this).data().contextMenuRoot; root.hovering = true; } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ menuMouseleave(e) { let root = $(this).data().contextMenuRoot; if (root.$layer &amp;&amp; root.$layer.is(e.relatedTarget)) { root.hovering = false; } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ itemMouseenter(e) { let $this = $(this); let data = $this.data(); let currentMenuData = data.contextMenu; let rootMenuData = data.contextMenuRoot; rootMenuData.hovering = true; // abort if we're re-entering if (e &amp;&amp; rootMenuData.$layer &amp;&amp; rootMenuData.$layer.is(e.relatedTarget)) { e.preventDefault(); e.stopImmediatePropagation(); } // make sure only one item is selected let targetMenu = (currentMenuData.$menu ? currentMenuData : rootMenuData); targetMenu.$menu .children('.' + rootMenuData.classNames.hover).trigger('contextmenu:blur', {data: targetMenu, originalEvent: e}) .children('.hover').trigger('contextmenu:blur', {data: targetMenu, originalEvent: e}); if ($this.hasClass(rootMenuData.classNames.disabled) || $this.hasClass(rootMenuData.classNames.notSelectable)) { currentMenuData.$selected = null; return; } $this.trigger('contextmenu:focus', {data: currentMenuData, originalEvent: e}); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ itemMouseleave(e) { let $this = $(this); let data = $this.data(); let currentMenuData = data.contextMenu; let rootMenuData = data.contextMenuRoot; if (rootMenuData !== currentMenuData &amp;&amp; rootMenuData.$layer &amp;&amp; rootMenuData.$layer.is(e.relatedTarget)) { if (typeof rootMenuData.$selected !== 'undefined' &amp;&amp; rootMenuData.$selected !== null) { rootMenuData.$selected.trigger('contextmenu:blur', {data: rootMenuData, originalEvent: e}); } e.preventDefault(); e.stopImmediatePropagation(); rootMenuData.$selected = currentMenuData.$selected = currentMenuData.$node; return; } if (currentMenuData &amp;&amp; currentMenuData.$menu &amp;&amp; currentMenuData.$menu.hasClass(rootMenuData.classNames.visible)) { return; } $this.trigger('contextmenu:blur'); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ itemClick(e) { let $this = $(this); let data = $this.data(); let currentMenuData = data.contextMenu; let rootMenuData = data.contextMenuRoot; let key = data.contextMenuKey; let callback; // abort if the key is unknown or disabled or is a menu if (!currentMenuData.items[key] || $this.is('.' + rootMenuData.classNames.disabled + ', .context-menu-separator, .' + rootMenuData.classNames.notSelectable) || ($this.is('.context-menu-submenu') &amp;&amp; rootMenuData.selectableSubMenu === false)) { return; } e.preventDefault(); e.stopImmediatePropagation(); if ($.isFunction(currentMenuData.callbacks[key]) &amp;&amp; Object.prototype.hasOwnProperty.call(currentMenuData.callbacks, key)) { // item-specific callback callback = currentMenuData.callbacks[key]; } else if ($.isFunction(rootMenuData.callback)) { // default callback callback = rootMenuData.callback; } else { // no callback, no action return; } // hide menu if callback doesn't stop that if (callback.call(rootMenuData.$trigger, e, key, currentMenuData, rootMenuData) !== false) { rootMenuData.$menu.trigger('contextmenu:hide'); } else if (rootMenuData.$menu.parent().length) { rootMenuData.manager.operations.update.call(rootMenuData.$trigger, e, rootMenuData); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ inputClick(e) { e.stopImmediatePropagation(); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e * @param {Object} data */ hideMenu(e, data) { console.log(e); console.log(e.originalEvent); const root = $(this).data('contextMenuRoot'); root.manager.operations.hide.call(root.$trigger, e, root, data &amp;&amp; data.force); } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ focusItem(e) { e.stopPropagation(); const $this = $(this); const data = $this.data(); const currentMenuData = data.contextMenu; const rootMenuData = data.contextMenuRoot; if ($this.hasClass(rootMenuData.classNames.disabled) || $this.hasClass(rootMenuData.classNames.notSelectable)) { return; } $this .addClass([rootMenuData.classNames.hover, rootMenuData.classNames.visible].join(' ')) // select other items and included items .parent().find('.context-menu-item').not($this) .removeClass(rootMenuData.classNames.visible) .filter('.' + rootMenuData.classNames.hover) .trigger('contextmenu:blur'); // remember selected currentMenuData.$selected = rootMenuData.$selected = $this; if (currentMenuData.$node &amp;&amp; currentMenuData.$node.hasClass('context-menu-submenu')) { currentMenuData.$node.addClass(rootMenuData.classNames.hover); } // position sub-menu - do after show so dumb $.ui.position can keep up if (currentMenuData.$node) { rootMenuData.positionSubmenu.call(currentMenuData.$node, e, currentMenuData.$menu); } } /** * @method * @memberOf ContextMenuEventHandler * @instance * * @param {ContextMenuEvent|JQuery.Event} e */ blurItem(e) { e.stopPropagation(); const $this = $(this); const data = $this.data(); const currentMenuData = data.contextMenu; const rootMenuData = data.contextMenuRoot; if (rootMenuData.autoHide) { // for tablets and touch screens this needs to remain $this.removeClass(rootMenuData.classNames.visible); } $this.removeClass(rootMenuData.classNames.hover); currentMenuData.$selected = null; } }; × Search results Close "},"classes_ContextMenuHtml5Builder.js.html":{"id":"classes_ContextMenuHtml5Builder.js.html","title":"Source: classes/ContextMenuHtml5Builder.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: classes/ContextMenuHtml5Builder.js /** * @class ContextMenuHtml5Builder * @classdesc considering the following HTML `$.contextMenu.fromMenu($('#html5menu'))` will return a proper items object. ``` &lt;menu id=&quot;html5menu&quot; type=&quot;context&quot; style=&quot;display:none&quot;&gt; &lt;command label=&quot;rotate&quot; onclick=&quot;alert('rotate')&quot;&gt; &lt;command label=&quot;resize&quot; onclick=&quot;alert('resize')&quot;&gt; &lt;menu label=&quot;share&quot;&gt; &lt;command label=&quot;twitter&quot; onclick=&quot;alert('twitter')&quot;&gt; &lt;hr&gt; &lt;command label=&quot;facebook&quot; onclick=&quot;alert('facebook')&quot;&gt; &lt;/menu&gt; &lt;/menu&gt; ``` `$.contextMenu.fromMenu()` will properly import (and thus handle) the following elements. Everything else is imported as `{type: &quot;html&quot;}` ``` &lt;menu&gt; &lt;hr&gt; &lt;a&gt; &lt;command type=&quot;command|radio|checkbox&quot;&gt; (W3C Specification) &lt;menuitem type=&quot;command|radio|checkbox&quot;&gt; (Firefox) &lt;input type=&quot;text|radio|checkbox&quot;&gt; &lt;select&gt; &lt;textarea&gt; &lt;label for=&quot;someId&quot;&gt; &lt;label&gt; the text &lt;input|textarea|select&gt; ``` The `&lt;menu&gt;` must be hidden but not removed, as all command events (clicks) are passed-thru to the original command element! Note: While the specs note `&lt;option&gt;`s to be renderd as regular commands, `$.contextMenu` will render an actual `&lt;select&gt;`. ## HTML5 `&lt;menu&gt;` shiv/polyfill Engaging the HTML5 polyfill (ignoring `$.contextMenu` if context menus are available natively): ``` $(function(){ $.contextMenu(&quot;html5&quot;); }); ``` Engaging the HTML5 polyfill (ignoring browser native implementation): ``` $(function(){ $.contextMenu(&quot;html5&quot;, true); }); ``` */ export default class ContextMenuHtml5Builder { /** * Get the input label for the given node. * * @method inputLabel * @memberOf ContextMenuHtml5Builder * @instance * * @param {HTMLElement} node - Html element * @returns {string|JQuery|jQuery} - Input label element */ inputLabel(node) { return (node.id &amp;&amp; $('label[for=&quot;' + node.id + '&quot;]').val()) || node.name; } /** * Helper function to build ContextMenuItems from an html5 menu element. * * @method fromMenu * @memberOf ContextMenuHtml5Builder * @instance * * @param {JQuery|string} element - Menu element to generate the menu from. * @returns {Object.&lt;string, ContextMenuItem&gt;} - Collection of {@link ContextMenuItem} */ fromMenu(element) { const $this = $(element); const items = {}; this.build(items, $this.children()); return items; } /** * Helper function for building a menu from a HTML menu element. * * @method build * @memberOf ContextMenuHtml5Builder * @instance * * @param {Object.&lt;string, ContextMenuItem&gt;} items - {@link ContextMenuItem} object to build. * @param {(JQuery)} $children - Collection of elements inside the `&lt;menu&gt;` element * @param {number?} counter - Counter to generate {@link ContextMenuItem} key names. * @returns {number} - Counter to generate {@link ContextMenuItem} key names. */ build(items, $children, counter) { if (!counter) { counter = 0; } let builder = this; $children.each(function () { let $node = $(this); let node = this; let nodeName = this.nodeName.toLowerCase(); let label; let item; // extract &lt;label&gt;&lt;input&gt; if (nodeName === 'label' &amp;&amp; $node.find('input, textarea, select').length) { label = $node.text(); $node = $node.children().first(); node = $node.get(0); nodeName = node.nodeName.toLowerCase(); } /* * &lt;menu&gt; accepts flow-content as children. that means &lt;embed&gt;, &lt;canvas&gt; and such are valid menu items. * Not being the sadistic kind, $.contextMenu only accepts: * &lt;command&gt;, &lt;menuitem&gt;, &lt;hr&gt;, &lt;span&gt;, &lt;p&gt; &lt;input [text, radio, checkbox]&gt;, &lt;textarea&gt;, &lt;select&gt; and of course &lt;menu&gt;. * Everything else will be imported as an html node, which is not interfaced with contextMenu. */ // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command switch (nodeName) { // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element case 'menu': item = {name: $node.attr('label'), items: {}}; counter = builder.build(item.items, $node.children(), counter); break; // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command case 'a': case 'button': item = { name: $node.text(), disabled: !!$node.attr('disabled'), callback: (function () { return function () { $node.get(0).click(); }; })() }; break; // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command case 'menuitem': case 'command': switch ($node.attr('type')) { case undefined: case 'command': case 'menuitem': item = { name: $node.attr('label'), disabled: !!$node.attr('disabled'), icon: $node.attr('icon'), callback: (function () { return function () { $node.get(0).click(); }; })() }; break; case 'checkbox': item = { type: 'checkbox', disabled: !!$node.attr('disabled'), name: $node.attr('label'), selected: !!$node.attr('checked') }; break; case 'radio': item = { type: 'radio', disabled: !!$node.attr('disabled'), name: $node.attr('label'), radio: $node.attr('radiogroup'), value: $node.attr('id'), selected: !!$node.attr('checked') }; break; default: item = undefined; } break; case 'hr': item = '-------'; break; case 'input': switch ($node.attr('type')) { case 'text': item = { type: 'text', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), value: $node.val() }; break; case 'checkbox': item = { type: 'checkbox', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), selected: !!$node.attr('checked') }; break; case 'radio': item = { type: 'radio', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), radio: !!$node.attr('name'), value: $node.val(), selected: !!$node.attr('checked') }; break; default: item = undefined; break; } break; case 'select': item = { type: 'select', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), selected: $node.val(), options: {} }; $node.children().each(function () { item.options[this.value] = $(this).text(); }); break; case 'textarea': item = { type: 'textarea', name: label || builder.inputLabel(node), disabled: !!$node.attr('disabled'), value: $node.val() }; break; case 'label': break; default: item = {type: 'html', html: $node.clone(true)}; break; } if (item) { counter++; items['key' + counter] = item; } }); return counter; } } × Search results Close "},"classes_ContextMenuItemTypes.js.html":{"id":"classes_ContextMenuItemTypes.js.html","title":"Source: classes/ContextMenuItemTypes.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: classes/ContextMenuItemTypes.js /** * @class ContextMenuItem * @instance * @interface * @classdesc The items map contains the commands to list in the menu. Each command has a unique key identifying an item object. The value may either be an item (properties explained below), or a string (which will insert a separator, disregarding the string's content). It is also possible to define a seperator the same as an item, and use the `type`:`cm_separator` to define it. ```javascript var items = { firstCommand: itemOptions, separator1: &quot;-----&quot;, separator2: { &quot;type&quot;: &quot;cm_separator&quot; }, command2: itemOptions } ``` Since 2.3 it is also possible to use a promise as item, so you can build submenu's based on a snynchronous promis. Check out the [demo using a promise](demo/async-promise.md) for an example how to use this. The example uses jQuery deferred, but any promise should do. Promised can only be used in combination with the [build option](docs#build). * * @property {string} name - Specify the human readable name of the command in the menu. This is used as the label for the option. * @property {boolean} isHtmlName - Should this item be called with .html() instead of .text(). Cannot be used with the accesskey option in the same item. * @property {ContextMenuItemCallback} callback - Specifies the callback to execute if the item is clicked. * @property {string} className - Specifies additional classNames to add to the menu item. Seperate multiple classes by using spaces. * @property {ContextMenuIconCallback|string} icon - Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like `.context-menu-item.context-menu-icon-edit`, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. * @property {ContextMenuItemCallback|boolean} disabled - Specifies if the command is disabled (`true`) or enabled (`false`). May be a callback returning a `boolean`. * @property {ContextMenuItemCallback|boolean} visible - Specifies if the command is disabled (`true`) or enabled (`false`). May be a callback returning a `boolean`. * @property {ContextMenuItemTypes|string} type - Specifies the type of the command. See {@link ContextMenuItemTypes}. * @property {Object&lt;string, Function&gt;} events - Events to register on a {@link ContextMenuItem}. The contents of the options object are passed as jQuery `e.data`. * @property {string} value - The value of the `&lt;input&gt;` element. * @property {boolean|string} selected - The selected option of a `select` element and the checked property for `checkbox` and `radio` {@link ContextMenuItemTypes}. * @property {string} radio - Specifies the group of the `radio` element. * @property {string} options - Specifies the options of the `select` element. * @property {Number} height - The height in pixels `&lt;textarea&gt;` element. If not specified, the height is defined by CSS. * @property {Object&lt;string, ContextMenuItem&gt;} items - Items to show in a sub-menu. You can nest as many as you like. * @property {string} accesskey - Character(s) to be used as accesskey. Considering `a b c` $.contextMenu will first try to use »a« as the accesskey, if already taken, it'll fall through to `b`. Words are reduced to the first character, so `hello world` is treated as `h w`. Note: Accesskeys are treated unique throughout one menu. This means an item in a sub-menu can't occupy the same accesskey as an item in the main menu. * * @property {?JQuery} $input - The input element if it was build for this item. * * @property {Object.&lt;string,ContextMenuItem&gt;} items Object containing the menu items. */ /** * Possible ContextMenuItem types * @enum string */ const ContextMenuItemTypes = { /** * The command is a simple clickable item. */ simple: '', /** * Makes the command an &amp;lt;input&amp;gt; of type text. The name followed by the &amp;lt;input&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ text: 'text', /** * Makes the command a &amp;lt;textarea&amp;gt;. The name followed by the &amp;lt;textarea&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ textarea: 'textarea', /** * Makes the command an &amp;lt;input&amp;gt; of type checkbox. The name followed by the &amp;lt;input&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ checkbox: 'checkbox', /** * Makes the command an &amp;lt;input&amp;gt; of type radio. The name followed by the &amp;lt;input&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ radio: 'radio', /** * Makes the command aa &amp;lt;select&amp;gt;. The name followed by the &amp;lt;select&amp;gt; are encapsulated in a &amp;lt;label&amp;gt;. */ select: 'select', /** * Makes an non-command element. When you select `type: 'html'` add the html to the html property. So: `{ item: { type: 'html', html: '&lt;span&gt;html!&lt;/span&gt;' } }`. You can also just use the item name with the `isHtmlName` property. */ html: 'html', /** * Internal property, used internally when the type is set to a string. */ separator: 'cm_separator', /** * Internal property for a {@link ContextMenuItem} that has an `items` property with other {@link ContextMenuItem} items. */ submenu: 'sub' }; export default ContextMenuItemTypes; × Search results Close "},"classes_ContextMenuOperations.js.html":{"id":"classes_ContextMenuOperations.js.html","title":"Source: classes/ContextMenuOperations.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: classes/ContextMenuOperations.js import ContextMenuHelper from './ContextMenuHelper'; import ContextMenuItemTypes from './ContextMenuItemTypes'; export default class ContextMenuOperations { /** * @constructor * @constructs ContextMenuOperations */ constructor() { return this; } /** * Show the menu. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} menuData * @param {number} x * @param {number} y */ show(e, menuData, x, y) { const $trigger = $(this); const css = {}; // hide any open menus $('#context-menu-layer').trigger('mousedown'); // backreference for callbacks menuData.$trigger = $trigger; // show event if (menuData.events.show.call($trigger, e, menuData) === false) { menuData.manager.handler.$currentTrigger = null; return; } // create or update context menu menuData.manager.operations.update.call($trigger, e, menuData); // position menu menuData.position.call($trigger, e, menuData, x, y); // make sure we're in front if (menuData.zIndex) { let additionalZValue = menuData.zIndex; // If menuData.zIndex is a function, call the function to get the right zIndex. if (typeof menuData.zIndex === 'function') { additionalZValue = menuData.zIndex.call($trigger, menuData); } css.zIndex = ContextMenuHelper.zindex($trigger) + additionalZValue; } // add layer menuData.manager.operations.layer.call(menuData.$menu, e, menuData, css.zIndex); // adjust sub-menu zIndexes menuData.$menu.find('ul').css('zIndex', css.zIndex + 1); // position and show context menu menuData.$menu.css(css)[menuData.animation.show](menuData.animation.duration, () =&gt; { $trigger.trigger('contextmenu:visible'); menuData.manager.operations.activated(e, menuData); menuData.events.activated($trigger, e, menuData); }); // make options available and set state $trigger .data('contextMenu', menuData) .addClass('context-menu-active'); // register key handler $(document).off('keydown.contextMenu').on('keydown.contextMenu', menuData, menuData.manager.handler.key); // register autoHide handler if (menuData.autoHide) { // mouse position handler $(document).on('mousemove.contextMenuAutoHide', function (e) { // need to capture the offset on mousemove, // since the page might've been scrolled since activation const pos = $trigger.offset(); pos.right = pos.left + $trigger.outerWidth(); pos.bottom = pos.top + $trigger.outerHeight(); if (menuData.$layer &amp;&amp; !menuData.hovering &amp;&amp; (!(e.pageX &gt;= pos.left &amp;&amp; e.pageX &lt;= pos.right) || !(e.pageY &gt;= pos.top &amp;&amp; e.pageY &lt;= pos.bottom))) { /* Additional hover check after short time, you might just miss the edge of the menu */ setTimeout(function () { if (!menuData.hovering &amp;&amp; menuData.$menu !== null &amp;&amp; typeof menuData.$menu !== 'undefined') { menuData.$menu.trigger('contextmenu:hide'); } }, 50); } }); } } /** * Hide the menu. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} menuData * @param {boolean} force */ hide(e, menuData, force) { const $trigger = $(this); if (typeof menuData !== 'object' &amp;&amp; $trigger.data('contextMenu')) { menuData = $trigger.data('contextMenu'); } else if (typeof menuData !== 'object') { return; } // hide event if (!force &amp;&amp; menuData.events &amp;&amp; menuData.events.hide.call($trigger, e, menuData) === false) { return; } // remove options and revert state $trigger .removeData('contextMenu') .removeClass('context-menu-active'); if (menuData.$layer) { // keep layer for a bit so the contextmenu event can be aborted properly by opera setTimeout((function ($layer) { return function () { $layer.remove(); }; })(menuData.$layer), 10); try { delete menuData.$layer; } catch (e) { menuData.$layer = null; } } // remove handle menuData.manager.handler.$currentTrigger = null; // remove selected menuData.$menu.find('.' + menuData.classNames.hover).trigger('contextmenu:blur'); menuData.$selected = null; // collapse all submenus menuData.$menu.find('.' + menuData.classNames.visible).removeClass(menuData.classNames.visible); // unregister key and mouse handlers $(document).off('.contextMenuAutoHide').off('keydown.contextMenu'); // hide menu if (menuData.$menu) { menuData.$menu[menuData.animation.hide](menuData.animation.duration, function () { // tear down dynamically built menu after animation is completed. if (menuData.build) { menuData.$menu.remove(); Object.keys(menuData).forEach((key) =&gt; { switch (key) { case 'ns': case 'selector': case 'build': case 'trigger': return true; default: menuData[key] = undefined; try { delete menuData[key]; } catch (e) { } return true; } }); } setTimeout(function () { $trigger.trigger('contextmenu:hidden'); }, 10); }); } } /** * Create a menu based on the options. Also created submenus. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} currentMenuData * @param {ContextMenuData?} rootMenuData */ create(e, currentMenuData, rootMenuData) { if (typeof rootMenuData === 'undefined') { rootMenuData = currentMenuData; } // create contextMenu currentMenuData.$menu = $('&lt;ul class=&quot;context-menu-list&quot;&gt;&lt;/ul&gt;').addClass(currentMenuData.className || '').data({ 'contextMenu': currentMenuData, 'contextMenuRoot': rootMenuData }); $.each(['callbacks', 'commands', 'inputs'], function (i, k) { currentMenuData[k] = {}; if (!rootMenuData[k]) { rootMenuData[k] = {}; } }); if (!rootMenuData.accesskeys) { rootMenuData.accesskeys = {}; } function createNameNode(item) { const $name = $('&lt;span&gt;&lt;/span&gt;'); if (item._accesskey) { if (item._beforeAccesskey) { $name.append(document.createTextNode(item._beforeAccesskey)); } $('&lt;span&gt;&lt;/span&gt;') .addClass('context-menu-accesskey') .text(item._accesskey) .appendTo($name); if (item._afterAccesskey) { $name.append(document.createTextNode(item._afterAccesskey)); } } else { if (item.isHtmlName) { // restrict use with access keys if (typeof item.accesskey !== 'undefined') { throw new Error('accesskeys are not compatible with HTML names and cannot be used together in the same item'); } $name.html(item.name); } else { $name.text(item.name); } } return $name; } // create contextMenu items $.each(currentMenuData.items, function (key, item) { let $t = $('&lt;li class=&quot;context-menu-item&quot;&gt;&lt;/li&gt;').addClass(item.className || ''); let $label = null; let $input = null; // iOS needs to see a click-event bound to an element to actually // have the TouchEvents infrastructure trigger the click event $t.on('click', $.noop); // Make old school string separator a real item so checks wont be // akward later. // And normalize 'cm_separator' into 'cm_separator'. if (typeof item === 'string' || item.type === 'cm_seperator') { item = {type: ContextMenuItemTypes.separator}; } item.$node = $t.data({ 'contextMenu': currentMenuData, 'contextMenuRoot': rootMenuData, 'contextMenuKey': key }); // register accesskey // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that if (typeof item.accesskey !== 'undefined') { const aks = ContextMenuHelper.splitAccesskey(item.accesskey); for (let i = 0, ak; ak = aks[i]; i++) { if (!rootMenuData.accesskeys[ak]) { rootMenuData.accesskeys[ak] = item; const matched = item.name.match(new RegExp('^(.*?)(' + ak + ')(.*)$', 'i')); if (matched) { item._beforeAccesskey = matched[1]; item._accesskey = matched[2]; item._afterAccesskey = matched[3]; } break; } } } if (item.type &amp;&amp; rootMenuData.types[item.type]) { // run custom type handler rootMenuData.types[item.type].call($t, e, item, currentMenuData, rootMenuData); // register commands $.each([currentMenuData, rootMenuData], function (i, k) { k.commands[key] = item; // Overwrite only if undefined or the item is appended to the rootMenuData. This so it // doesn't overwrite callbacks of rootMenuData elements if the name is the same. if ($.isFunction(item.callback) &amp;&amp; (typeof k.callbacks[key] === 'undefined' || typeof currentMenuData.type === 'undefined')) { k.callbacks[key] = item.callback; } }); } else { // add label for input if (item.type === ContextMenuItemTypes.separator) { $t.addClass('context-menu-separator ' + rootMenuData.classNames.notSelectable); } else if (item.type === ContextMenuItemTypes.html) { $t.addClass('context-menu-html ' + rootMenuData.classNames.notSelectable); } else if (item.type &amp;&amp; item.type !== ContextMenuItemTypes.submenu) { $label = $('&lt;label&gt;&lt;/label&gt;').appendTo($t); createNameNode(item).appendTo($label); $t.addClass('context-menu-input'); currentMenuData.hasTypes = true; $.each([currentMenuData, rootMenuData], function (i, k) { k.commands[key] = item; k.inputs[key] = item; }); } else if (item.items) { item.type = ContextMenuItemTypes.submenu; } switch (item.type) { case ContextMenuItemTypes.separator: break; case ContextMenuItemTypes.text: $input = $('&lt;input type=&quot;text&quot; value=&quot;1&quot; name=&quot;&quot; /&gt;') .attr('name', 'context-menu-input-' + key) .val(item.value || '') .appendTo($label); break; case ContextMenuItemTypes.textarea: $input = $('&lt;textarea name=&quot;&quot;&gt;&lt;/textarea&gt;') .attr('name', 'context-menu-input-' + key) .val(item.value || '') .appendTo($label); if (item.height) { $input.height(item.height); } break; case ContextMenuItemTypes.checkbox: $input = $('&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; name=&quot;&quot; /&gt;') .attr('name', 'context-menu-input-' + key) .val(item.value || '') .prop('checked', !!item.selected) .prependTo($label); break; case ContextMenuItemTypes.radio: $input = $('&lt;input type=&quot;radio&quot; value=&quot;1&quot; name=&quot;&quot; /&gt;') .attr('name', 'context-menu-input-' + item.radio) .val(item.value || '') .prop('checked', !!item.selected) .prependTo($label); break; case ContextMenuItemTypes.select: $input = $('&lt;select name=&quot;&quot;&gt;&lt;/select&gt;') .attr('name', 'context-menu-input-' + key) .appendTo($label); if (item.options) { $.each(item.options, function (value, text) { $('&lt;option&gt;&lt;/option&gt;').val(value).text(text).appendTo($input); }); $input.val(item.selected); } break; case ContextMenuItemTypes.submenu: createNameNode(item).appendTo($t); item.appendTo = item.$node; $t.data('contextMenu', item).addClass('context-menu-submenu'); item.callback = null; // If item contains items, and this is a promise, we should create it later // check if subitems is of type promise. If it is a promise we need to create // it later, after promise has been resolved. if (typeof item.items.then === 'function') { // probably a promise, process it, when completed it will create the sub menu's. rootMenuData.manager.operations.processPromises(e, item, rootMenuData, item.items); } else { // normal submenu. rootMenuData.manager.operations.create(e, item, rootMenuData); } break; case ContextMenuItemTypes.html: $(item.html).appendTo($t); break; default: $.each([currentMenuData, rootMenuData], function (i, k) { k.commands[key] = item; // Overwrite only if undefined or the item is appended to the rootMenuData. This so it // doesn't overwrite callbacks of rootMenuData elements if the name is the same. if ($.isFunction(item.callback) &amp;&amp; (typeof k.callbacks[key] === 'undefined' || typeof currentMenuData.type === 'undefined')) { k.callbacks[key] = item.callback; } }); createNameNode(item).appendTo($t); break; } // disable key listener in &lt;input&gt; if (item.type &amp;&amp; item.type !== ContextMenuItemTypes.submenu &amp;&amp; item.type !== ContextMenuItemTypes.html &amp;&amp; item.type !== ContextMenuItemTypes.separator) { $input .on('focus', rootMenuData.manager.handler.focusInput) .on('blur', rootMenuData.manager.handler.blurInput); if (item.events) { $input.on(item.events, currentMenuData); } } // add icons if (item.icon) { if ($.isFunction(item.icon)) { item._icon = item.icon.call(this, e, $t, key, item, currentMenuData, rootMenuData); } else { if (typeof (item.icon) === 'string' &amp;&amp; item.icon.substring(0, 3) === 'fa-') { // to enable font awesome item._icon = rootMenuData.classNames.icon + ' ' + rootMenuData.classNames.icon + '--fa fa ' + item.icon; } else { item._icon = rootMenuData.classNames.icon + ' ' + rootMenuData.classNames.icon + '-' + item.icon; } } $t.addClass(item._icon); } } // cache contained elements item.$input = $input; item.$label = $label; // attach item to menu $t.appendTo(currentMenuData.$menu); // Disable text selection if (!currentMenuData.hasTypes &amp;&amp; $.support.eventSelectstart) { // browsers support user-select: none, // IE has a special event for text-selection // browsers supporting neither will not be preventing text-selection $t.on('selectstart.disableTextSelect', currentMenuData.manager.handler.abortevent); } }); // attach contextMenu to &lt;body&gt; (to bypass any possible overflow:hidden issues on parents of the trigger element) if (!currentMenuData.$node) { currentMenuData.$menu.css('display', 'none').addClass('context-menu-rootMenuData'); } currentMenuData.$menu.appendTo(currentMenuData.appendTo || document.body); } /** * Resize the menu to its content. * * @method * @memberOf ContextMenuOperations * @instance * * @param {ContextMenuEvent} e * @param {JQuery} $menu * @param {boolean?} nested */ resize(e, $menu, nested) { let domMenu; // determine widths of submenus, as CSS won't grow them automatically // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100; // kinda sucks hard... // determine width of absolutely positioned element $menu.css({position: 'absolute', display: 'block'}); // don't apply yet, because that would break nested elements' widths $menu.data('width', (domMenu = $menu.get(0)).getBoundingClientRect ? Math.ceil(domMenu.getBoundingClientRect().width) : $menu.outerWidth() + 1); // outerWidth() returns rounded pixels // reset styles so they allow nested elements to grow/shrink naturally $menu.css({ position: 'static', minWidth: '0px', maxWidth: '100000px' }); // identify width of nested menus $menu.find('&gt; li &gt; ul').each((index, element) =&gt; { e.data.manager.operations.resize(e, $(element), true); }); // reset and apply changes in the end because nested // elements' widths wouldn't be calculatable otherwise if (!nested) { $menu.find('ul').addBack().css({ position: '', display: '', minWidth: '', maxWidth: '' }).outerWidth(function () { return $(this).data('width'); }); } } /** * Update the contextmenu, re-evaluates the whole menu (including disabled/visible callbacks) * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData?} currentMenuData * @param {ContextMenuData?} rootMenuData */ update(e, currentMenuData, rootMenuData) { const $trigger = this; if (typeof rootMenuData === 'undefined') { rootMenuData = currentMenuData; rootMenuData.manager.operations.resize(e, currentMenuData.$menu); } // re-check disabled for each item currentMenuData.$menu.children().each(function (index, element) { let $item = $(element); let key = $item.data('contextMenuKey'); let item = currentMenuData.items[key]; let disabled = ($.isFunction(item.disabled) &amp;&amp; item.disabled.call($trigger, e, key, currentMenuData, rootMenuData)) || item.disabled === true; let visible; if ($.isFunction(item.visible)) { visible = item.visible.call($trigger, e, key, currentMenuData, rootMenuData); } else if (typeof item.visible !== 'undefined') { visible = item.visible === true; } else { visible = true; } $item[visible ? 'show' : 'hide'](); // dis- / enable item $item[disabled ? 'addClass' : 'removeClass'](rootMenuData.classNames.disabled); if ($.isFunction(item.icon)) { $item.removeClass(item._icon); item._icon = item.icon.call(this, $trigger, $item, key, item); $item.addClass(item._icon); } if (item.type) { // dis- / enable input elements $item.find('input, select, textarea').prop('disabled', disabled); // update input states switch (item.type) { case ContextMenuItemTypes.text: case ContextMenuItemTypes.textarea: item.$input.val(item.value || ''); break; case ContextMenuItemTypes.checkbox: case ContextMenuItemTypes.radio: item.$input.val(item.value || '').prop('checked', !!item.selected); break; case ContextMenuItemTypes.select: item.$input.val((item.selected === 0 ? '0' : item.selected) || ''); break; } } if (item.$menu) { // update sub-menu rootMenuData.manager.operations.update.call($trigger, e, item, rootMenuData); } }); } /** * Create the overlay layer so we can capture the click outside the menu and close it. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} menuData * @param {number} zIndex * @returns {jQuery} */ layer(e, menuData, zIndex) { const $window = $(window); // add transparent layer for click area // filter and background for Internet Explorer, Issue #23 const $layer = menuData.$layer = $('&lt;div id=&quot;context-menu-layer&quot;&gt;&lt;/div&gt;') .css({ height: $window.height(), width: $window.width(), display: 'block', position: 'fixed', 'z-index': zIndex, top: 0, left: 0, opacity: 0, filter: 'alpha(opacity=0)', 'background-color': '#000' }) .data('contextMenuRoot', menuData) .insertBefore(this) .on('contextmenu', menuData.manager.handler.abortevent) .on('mousedown', menuData.manager.handler.layerClick); // IE6 doesn't know position:fixed; if (typeof document.body.style.maxWidth === 'undefined') { // IE6 doesn't support maxWidth $layer.css({ 'position': 'absolute', 'height': $(document).height() }); } return $layer; } /** * Process submenu promise. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} currentMenuData * @param {ContextMenuData} rootMenuData * @param {Promise} promise */ processPromises(e, currentMenuData, rootMenuData, promise) { // Start currentMenuData.$node.addClass(rootMenuData.classNames.iconLoadingClass); function finishPromiseProcess(currentMenuData, rootMenuData, items) { if (typeof rootMenuData.$menu === 'undefined' || !rootMenuData.$menu.is(':visible')) { return; } currentMenuData.$node.removeClass(rootMenuData.classNames.iconLoadingClass); currentMenuData.items = items; rootMenuData.manager.operations.create(e, currentMenuData, rootMenuData); // Create submenu rootMenuData.manager.operations.update(e, currentMenuData, rootMenuData); // Correctly update position if user is already hovered over menu item rootMenuData.positionSubmenu.call(currentMenuData.$node, e, currentMenuData.$menu); // positionSubmenu, will only do anything if user already hovered over menu item that just got new subitems. } function errorPromise(currentMenuData, rootMenuData, errorItem) { // User called promise.reject() with an error item, if not, provide own error item. if (typeof errorItem === 'undefined') { errorItem = { 'error': { name: 'No items and no error item', icon: 'context-menu-icon context-menu-icon-quit' } }; if (window.console) { (console.error || console.log).call(console, 'When you reject a promise, provide an &quot;items&quot; object, equal to normal sub-menu items'); } } else if (typeof errorItem === 'string') { errorItem = {'error': {name: errorItem}}; } finishPromiseProcess(currentMenuData, rootMenuData, errorItem); } function completedPromise(currentMenuData, rootMenuData, items) { // Completed promise (dev called promise.resolve). We now have a list of items which can // be used to create the rest of the context menu. if (typeof items === 'undefined') { // Null result, dev should have checked errorPromise(undefined); // own error object } finishPromiseProcess(currentMenuData, rootMenuData, items); } // Wait for promise completion. .then(success, error, notify) (we don't track notify). Bind the currentMenuData // and rootMenuData to avoid scope problems promise.then(completedPromise.bind(this, currentMenuData, rootMenuData), errorPromise.bind(this, currentMenuData, rootMenuData)); } /** * Operation that will run after contextMenu showed on screen. * * @method * @memberOf ContextMenuOperations * @instance * * @param {JQuery.Event} e * @param {ContextMenuData} menuData * @return {undefined} */ activated(e, menuData) { const $menu = menuData.$menu; const $menuOffset = $menu.offset(); const winHeight = $(window).height(); const winScrollTop = $(window).scrollTop(); const menuHeight = $menu.height(); if (menuHeight &gt; winHeight) { $menu.css({ 'height': winHeight + 'px', 'overflow-x': 'hidden', 'overflow-y': 'auto', 'top': winScrollTop + 'px' }); } else if (($menuOffset.top &lt; winScrollTop) || ($menuOffset.top + menuHeight &gt; winScrollTop + winHeight)) { $menu.css({ 'top': '0px' }); } } }; × Search results Close "},"jquery_contextMenuFunction.js.html":{"id":"jquery_contextMenuFunction.js.html","title":"Source: jquery/contextMenuFunction.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: jquery/contextMenuFunction.js /** * The jQuery plugin namespace. * @external &quot;jQuery.fn&quot; * @see {@link http://docs.jquery.com/Plugins/Authoring The jQuery Plugin Guide} */ /** * Function that is called when calling contextmenu on an element (eg. $('.contextmenu').contextMenu()). * * @instance * @function external:jQuery.fn.contextmenu * * @param {(string|Object)} operation * @returns {JQuery} */ export default function (operation) { const $t = this; const $o = operation; if ($t.length &gt; 0) { // this is not a build on demand menu if (typeof operation === 'undefined') { $t.first().trigger('contextmenu'); } else if (typeof operation.x !== 'undefined' &amp;&amp; typeof operation.y !== 'undefined') { $t.first().trigger($.Event('contextmenu', { pageX: operation.x, pageY: operation.y, mouseButton: operation.button })); } else if (operation === 'hide') { const $menu = this.first().data('contextMenu') ? this.first().data('contextMenu').$menu : null; if ($menu) { $menu.trigger('contextmenu:hide'); } } else if (operation === 'destroy') { $.contextMenu('destroy', {context: this}); } else if (operation === 'update') { $.contextMenu('update', {context: this}); } else if ($.isPlainObject(operation)) { operation.context = this; $.contextMenu('create', operation); } else if (operation === true) { $t.removeClass('context-menu-disabled'); } else if (operation === false) { $t.addClass('context-menu-disabled'); } } else { // eslint-disable-next-line no-undef $.each($.contextMenu.menus, function () { if (this.selector === $t.selector) { $o.data = this; $.extend($o.data, {trigger: 'demand'}); } }); $.contextMenu.handle.contextmenu.call($o.target, $o); } return this; } × Search results Close "},"contextmenu.js.html":{"id":"contextmenu.js.html","title":"Source: contextmenu.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: contextmenu.js 'use strict'; import '../sass/jquery.contextMenu.scss'; import ContextMenu from './classes/ContextMenu'; import elementFunction from './jquery/contextMenuFunction'; /** * The jQuery namespace. * @external &quot;jQuery&quot; * @see {@link http://docs.jquery.com/Plugins/Authoring The jQuery Plugin Guide} */ /** * @class jQuery.contextMenu * @function external:jQuery.contextMenu * @instance * * @param {string} operation * @param {ContextMenuOptions} options * * @property {ContextMenu} manager * @property {getInputValues} getInputValues * @property {setInputValues} setInputValues * @property {fromMenu} ContextMenuHtml5Builder#fromMenu * @property {ContextMenuOptions} defaults * @property {ContextMenuEventHandler} handle * @property {ContextMenuOperations} operations * @property {Object&lt;string, ContextMenuData&gt;} menus */ const manager = new ContextMenu(); // manage contextMenu instances let contextMenu = function (operation, options) { manager.execute(operation, options); }; contextMenu.getInputValues = function (currentMenuData, data) { return manager.getInputValues(currentMenuData, data); }; contextMenu.setInputValues = function (currentMenuData, data) { return manager.getInputValues(currentMenuData, data); }; contextMenu.fromMenu = function (element) { return manager.html5builder.fromMenu(element); }; // make defaults accessible contextMenu.defaults = manager.defaults; contextMenu.types = manager.defaults.types; contextMenu.manager = manager; // export internal functions - undocumented, for hacking only! contextMenu.handle = manager.handler; contextMenu.operations = manager.operations; contextMenu.menus = manager.menus; contextMenu.namespaces = manager.namespaces; $.fn.contextMenu = elementFunction; $.contextMenu = contextMenu; module.exports = ContextMenu; × Search results Close "},"classes_ContextMenuHelper.js.html":{"id":"classes_ContextMenuHelper.js.html","title":"Source: classes/ContextMenuHelper.js","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Source: classes/ContextMenuHelper.js export default class ContextMenuHelper { /** * @param {JQuery} $t - Element to calculate z-index of. * @return {number} - Elements zIndex */ static zindex($t) { let zin = 0; let $tt = $t; while (true) { zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0); $tt = $tt.parent(); if (!$tt || !$tt.length || 'html body'.indexOf($tt.prop('nodeName').toLowerCase()) &gt; -1) { break; } } return zin; } /** * Split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key * @param {string} val - Accesskey value * @return {Array} - Seperate keys to handle as accesskey */ static splitAccesskey(val) { let t = val.split(/\\s+/); let keys = []; for (let i = 0, k; k = t[i]; i++) { k = k.charAt(0).toUpperCase(); // first character only // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it. // a map to look up already used access keys would be nice keys.push(k); } return keys; } } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Global Members &lt;constant&gt; ContextMenuItemTypes Possible ContextMenuItem types Properties: Name Type Default Description simple The command is a simple clickable item. text text Makes the command an &lt;input&gt; of type text. The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. textarea textarea Makes the command a &lt;textarea&gt;. The name followed by the &lt;textarea&gt; are encapsulated in a &lt;label&gt;. checkbox checkbox Makes the command an &lt;input&gt; of type checkbox. The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. radio radio Makes the command an &lt;input&gt; of type radio. The name followed by the &lt;input&gt; are encapsulated in a &lt;label&gt;. select select Makes the command aa &lt;select&gt;. The name followed by the &lt;select&gt; are encapsulated in a &lt;label&gt;. html html Makes an non-command element. When you select type: 'html' add the html to the html property. So: { item: { type: 'html', html: '&lt;span&gt;html!&lt;/span&gt;' } }. You can also just use the item name with the isHtmlName property. separator cm_separator Internal property, used internally when the type is set to a string. submenu sub Internal property for a ContextMenuItem that has an items property with other ContextMenuItem items. Source: classes/ContextMenuItemTypes.js, line 51 Methods buildOptions(userOptions) Build the options, by applying the Manager, defaults, user options and normalizing the context. Parameters: Name Type Description userOptions ContextMenuOptions Source: classes/ContextMenu.js, line 278 Returns: Type ContextMenuOptions create(options) Create a ContextMenu Parameters: Name Type Description options ContextMenuOptions Source: classes/ContextMenu.js, line 168 destroy(options) Destroy the ContextMenu Parameters: Name Type Description options ContextMenuOptions Source: classes/ContextMenu.js, line 101 html5(options) if is not handled by the browser, or options was a bool true, initialize $.contextMenu for them. Parameters: Name Type Description options ContextMenuOptions | boolean Source: classes/ContextMenu.js, line 80 normalizeArguments(operation, options) Parameters: Name Type Description operation string | Object options string | Object | ContextMenuOptions Source: classes/ContextMenu.js, line 301 Returns: Type Object splitAccesskey(val) Split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key Parameters: Name Type Description val string Accesskey value Source: classes/ContextMenuHelper.js, line 26 Returns: Seperate keys to handle as accesskey Type Array update(options) Update the ContextMenu or all ContextMenu's Parameters: Name Type Description options ContextMenuOptions Source: classes/ContextMenu.js, line 259 zindex($t) Parameters: Name Type Description $t JQuery Element to calculate z-index of. Source: classes/ContextMenuHelper.js, line 7 Returns: Elements zIndex Type number Type Definitions ContextMenuBuildCallback(e, $currentTrigger) Parameters: Name Type Description e JQuery.Event Event that trigged the menu. $currentTrigger JQuery Element that trigged the menu. Source: defaults/interfaces.js, line 80 Returns: Type Object.&lt;string, ContextMenuItem&gt; ContextMenuEvent Type: jQuery.Event Properties: Name Type Description data ContextMenuData Source: classes/ContextMenuEventHandler.js, line 3 ContextMenuIconCallback(e,, $t, key, item, currentMenuData, rootMenuData) Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like .context-menu-item.context-menu-icon-edit, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. Parameters: Name Type Description e, ContextMenuEvent | JQuery.Event $t JQuery key string item ContextMenuItem currentMenuData ContextMenuData rootMenuData ContextMenuData Source: defaults/interfaces.js, line 1 Example var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, currentMenuData, rootMenuData){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + currentMenuData.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } ContextMenuIconCallback(e,, $t, key, item, currentMenuData, rootMenuData) Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like .context-menu-item.context-menu-icon-edit, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. Parameters: Name Type Description e, ContextMenuEvent | JQuery.Event $t JQuery key string item ContextMenuItem currentMenuData ContextMenuData rootMenuData ContextMenuData Source: defaults/interfaces.js, line 35 Example var items = { firstCommand: { name: &quot;Copy&quot;, icon: function(e, $itemElement, itemKey, item, currentMenuData, rootMenuData){ // Set the content to the menu trigger selector and add an bootstrap icon to the item. $itemElement.html('&lt;span class=&quot;glyphicon glyphicon-star&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; ' + currentMenuData.selector); // Add the context-menu-icon-updated class to the item return 'context-menu-icon-updated'; } }, secondCommand: { name: &quot;Paste&quot;, icon: &quot;paste&quot; // Class context-menu-icon-paste is used on the menu item. } } ContextMenuItemCallback(e, key, currentMenuData, rootMenuData) The Callback is executed in the context of the triggering object. Parameters: Name Type Description e JQuery.Event Event that trigged the menu. key string Key of the menu item. currentMenuData ContextMenuData Data of the (sub)menu in which the item resides. rootMenuData ContextMenuData Data of the root menu in which the item resides. Might be the same as currentMenuData if triggered in the menu root. Source: defaults/interfaces.js, line 69 Returns: Type boolean ContextMenuItemTypeCallback(e, item, currentMenuData, rootMenuData) Runs in the scope of the &lt;li&gt; of the contextmenu. Parameters: Name Type Description e JQuery.Event Event that trigged the menu. item ContextMenuItem Menu item currentMenuData ContextMenuData Data of the (sub)menu in which the item resides. rootMenuData ContextMenuData Data of the root menu in which the item resides. Might be the same as currentMenuData if triggered in the menu root. Source: defaults/interfaces.js, line 87 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Classes Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Interfaces Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Externals Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Tutorials Classes ContextMenu ContextMenuEventHandler ContextMenuHtml5Builder ContextMenuOperations × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery jQuery contextMenu plugin &amp; polyfill $.contextMenu is a management facility for - you guessed it - context menus. It was designed for an application where there are hundreds of elements that may show a context menu - so intialization speed and memory usage are kept fairly small. It also allows to register context menus without providing actual markup, as $.contextMenu generates DOMElements as needed. features -demo -documentation Dependencies jQuery &gt;=1.8.2 jQuery UI position (optional but recommended) Usageregister contextMenu from javascript: $.contextMenu({ // define which elements trigger this menu selector: &quot;.with-cool-menu&quot;, // define the elements of the menu items: { foo: {name: &quot;Foo&quot;, callback: function(e, key, currentMenuData){ alert(&quot;Foo!&quot;); }}, bar: {name: &quot;Bar&quot;, callback: function(e, key, currentMenuData){ alert(&quot;Bar!&quot;) }} } // there's more, have a look at the demos and docs... });have a look at the demos. Version 3.0Version 3.0 is a restructure of the javascript into something more sane written in ES6. It consolidates all API's so callbacks are better documented and more concise. The basics are still the same, but all callbacks are structured differently. The goal of this refactor was mostly to make the ContextMenu easier to maintain, and make the API's more consise. It also adds JSdoc comments so the API documentation is generated from the code and it enables code completion. Code coverage is also introduced in the test suite. If you really want you can also use the ContextMenu class to instantiate the menu objects instead of the jQuery calls. It still requires jQuery to function. import ContextMenu from 'jquery-contextmenu'; const contextMenu = new ContextMenu(); contextMenu.create({ // define which elements trigger this menu selector: &quot;.with-cool-menu&quot;, // define the elements of the menu items: { foo: {name: &quot;Foo&quot;, callback: function(e, key, currentMenuData){ alert(&quot;Foo!&quot;); }}, bar: {name: &quot;Bar&quot;, callback: function(e, key, currentMenuData){ alert(&quot;Bar!&quot;) }} } // there's more, have a look at the demos and docs... });HTML5 CompatibilityFirefox 8 implemented contextmenu using the &lt;menuitem&gt; tags for menu-structure. The specs however state that &lt;command&gt; tags should be used for this purpose. $.contextMenu accepts both. Firefox 8 does not yet fully implement the contextmenu specification (Ticket #617528). The elementsa,button,input andoptionusable as commands are being ignored altogether. It also doesn't (optically) distinguish between checkbox/radio and regular commands (Bug #705292). contextmenu specs command specs Browser support according to caniuse.com Note: While the specs note &lt;option&gt;s to be renderd as regular commands, $.contextMenu will render an actual &lt;select&gt;. import contextMenu from HTML5 &lt;menu&gt;: $.contextMenu(&quot;html5&quot;);Interaction PrinciplesYou're (obviously) able to use the context menu with your mouse. Once it is opened, you can also use the keyboard to (fully) navigate it. ↑ (up) previous item in list, will skip disabled elements and wrap around ↓ (down) next item in, will skip disabled elements and wrap around → (right) dive into sub-menu ← (left) rise from sub-menu ↵ (return) invoke command ⇥ (tab) next item or input element, will skip disabled elements and wrap around ⇪ ⇥ (shift tab) previous item or input element, will skip disabled elements and wrap around ⎋ (escape) close menu ⌴ (space) captured and ignore to avoid page scrolling (for consistency with native menus) ⇞ (page up) captured and ignore to avoid page scrolling (for consistency with native menus) ⇟ (page down) captured and ignore to avoid page scrolling (for consistency with native menus) ↖ (home) first item in list, will skip disabled elements ↘ (end) last item in list, will skip disabled elements Besides the obvious, browser also react to alphanumeric key strokes. Hitting r in a context menu will make Firefox (8) reload the page immediately. Chrome selects the option to see infos on the page, Safari selects the option to print the document. Awesome, right? Until trying the same on Windows I did not realize that the browsers were using the access-key for this. I would've preferred typing the first character of something, say &quot;s&quot; for &quot;save&quot; and then iterate through all the commands beginning with s. But that's me - what do I know about UX? Anyways, $.contextMenu now also supports accesskey handling. Authors Björn Brala Rodney Rehm (original creator) Christiaan Baartse (single callback per menu) Addy Osmani (compatibility with native context menu in Firefox 8) Special thanksFont-Awesome icons used from encharm/Font-Awesome-SVG-PNG. × Search results Close "},"ContextMenu.html":{"id":"ContextMenu.html","title":"Class: ContextMenu","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Class: ContextMenu ContextMenu The ContextMenu is the core class that manages contextmenu's. You can call this class directly and skip going through jQuery. new ContextMenu() Properties: Name Type Description defaults ContextMenuOptions | Object handle ContextMenuEventHandler operations ContextMenuOperations menus Object.&lt;string, ContextMenuData&gt; counter number Internal counter to keep track of different menu's on the page. initialized boolean Flag the menu as initialized. Source: classes/ContextMenu.js, line 7 Example // You can call this class directly and skip going through jQuery, although it still requires jQuery to run. const manager = new ContextMenu(); manager.execute(&quot;create&quot;, options); Methods execute(operation, options) Parameters: Name Type Description operation string | ContextMenuOptions options string | ContextMenuOptions Source: classes/ContextMenu.js, line 36 Returns: Type ContextMenu getInputValues(contextMenuData, data) export values from &lt;input&gt; commands Parameters: Name Type Description contextMenuData ContextMenuData ContextMenuData object data Object Values object Source: classes/ContextMenu.js, line 353 Returns: Values of input elements Type Object setInputValues(contextMenuData, data) import values into &lt;input&gt; commands Parameters: Name Type Description contextMenuData ContextMenuData ContextMenuData object data Object Values to set Source: classes/ContextMenu.js, line 315 Returns: Type undefined × Search results Close "},"ContextMenuData.html":{"id":"ContextMenuData.html","title":"Interface: ContextMenuData","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Interface: ContextMenuData ContextMenuData Properties: Name Type Argument Description $menu JQuery The menu element for this menu part. Eg. the root menu, or a single submenu. $layer JQuery The opened layer when the menu is opened. $node JQuery The menu node. $trigger JQuery The element that triggered opening the menu. $selected JQuery Reference to the &lt;li&gt; command element. $input JQuery Reference to the &lt;input&gt; or &lt;select&gt; of the command element. $label JQuery Reference to the &lt;input&gt; or &lt;select&gt; of the command element. ns string The namespace (including leading dot) all events for this contextMenu instance were registered under. manager ContextMenu The contextmenu manager instance. $selected JQuery | jQuery | null Currently selected menu item, or input inside menu item. hasTypes boolean &lt;nullable&gt; The menu has ContextMenuItem which are of a selectable type. isInput boolean &lt;nullable&gt; We are currently originating events from an input. inputs Object.&lt;string, ContextMenuItem&gt; Inputs defined in the menu. types Object.&lt;string, ContextMenuItemTypeCallback&gt; Custom ContextMenuItemTypes, key is the ContextMenuItem type property, value is a ContextMenuItemTypeCallback callback. hovering boolean Currently hovering, root menu only. Source: defaults/index.js, line 3 Extends ContextMenuOptions Methods determinePosition($menu) Determine the position for a root menu. Parameters: Name Type Description $menu JQuery Inherited From: ContextMenuOptions#determinePosition Source: defaults/position.js, line 1 position(e, currentMenuData, x, y) Position the root menu. Parameters: Name Type Description e JQuery.Event currentMenuData ContextMenuData x number | string y number | string Inherited From: ContextMenuOptions#position Source: defaults/position.js, line 28 positionSubmenu(e, $menu) Position a submenu. Parameters: Name Type Description e JQuery.Event $menu JQuery Inherited From: ContextMenuOptions#positionSubmenu Source: defaults/position.js, line 78 × Search results Close "},"ContextMenuEventHandler.html":{"id":"ContextMenuEventHandler.html","title":"Class: ContextMenuEventHandler","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Class: ContextMenuEventHandler ContextMenuEventHandler new ContextMenuEventHandler() Properties: Name Type Argument Description $currentTrigger JQuery &lt;nullable&gt; hoveract Object Source: classes/ContextMenuEventHandler.js, line 16 Methods abortevent(e) Helper to abort an event Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 30 blurInput(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 666 blurItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 880 click(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 135 contextmenu(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 42 focusInput(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 649 focusItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 841 hideMenu(e, data) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event data Object Source: classes/ContextMenuEventHandler.js, line 827 inputClick(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 815 itemClick(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 773 itemMouseenter(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 708 itemMouseleave(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 743 key(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 371 keyStop(e, currentMenuData) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event currentMenuData ContextMenuItem Source: classes/ContextMenuEventHandler.js, line 356 layerClick(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 263 menuMouseenter(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 682 menuMouseleave(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 694 mousedown(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 148 mouseenter(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 190 mouseleave(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 240 mousemove(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 228 mouseup(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 170 nextItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 598 prevItem(e) Parameters: Name Type Description e ContextMenuEvent | JQuery.Event Source: classes/ContextMenuEventHandler.js, line 546 × Search results Close "},"ContextMenuHtml5Builder.html":{"id":"ContextMenuHtml5Builder.html","title":"Class: ContextMenuHtml5Builder","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Class: ContextMenuHtml5Builder ContextMenuHtml5Builder considering the following HTML $.contextMenu.fromMenu($('#html5menu')) will return a proper items object. &lt;menu id=&quot;html5menu&quot; type=&quot;context&quot; style=&quot;display:none&quot;&gt; &lt;command label=&quot;rotate&quot; onclick=&quot;alert('rotate')&quot;&gt; &lt;command label=&quot;resize&quot; onclick=&quot;alert('resize')&quot;&gt; &lt;menu label=&quot;share&quot;&gt; &lt;command label=&quot;twitter&quot; onclick=&quot;alert('twitter')&quot;&gt; &lt;hr&gt; &lt;command label=&quot;facebook&quot; onclick=&quot;alert('facebook')&quot;&gt; &lt;/menu&gt; &lt;/menu&gt; $.contextMenu.fromMenu() will properly import (and thus handle) the following elements. Everything else is imported as {type: &quot;html&quot;} &lt;menu&gt; &lt;hr&gt; &lt;a&gt; &lt;command type=&quot;command|radio|checkbox&quot;&gt; (W3C Specification) &lt;menuitem type=&quot;command|radio|checkbox&quot;&gt; (Firefox) &lt;input type=&quot;text|radio|checkbox&quot;&gt; &lt;select&gt; &lt;textarea&gt; &lt;label for=&quot;someId&quot;&gt; &lt;label&gt; the text &lt;input|textarea|select&gt; The &lt;menu&gt; must be hidden but not removed, as all command events (clicks) are passed-thru to the original command element! Note: While the specs note &lt;option&gt;s to be renderd as regular commands, $.contextMenu will render an actual &lt;select&gt;. HTML5 &lt;menu&gt; shiv/polyfill Engaging the HTML5 polyfill (ignoring $.contextMenu if context menus are available natively): $(function(){ $.contextMenu(&quot;html5&quot;); }); Engaging the HTML5 polyfill (ignoring browser native implementation): $(function(){ $.contextMenu(&quot;html5&quot;, true); }); new ContextMenuHtml5Builder() Source: classes/ContextMenuHtml5Builder.js, line 1 Methods build(items, $children, counter) Helper function for building a menu from a HTML menu element. Parameters: Name Type Argument Description items Object.&lt;string, ContextMenuItem&gt; ContextMenuItem object to build. $children JQuery Collection of elements inside the &lt;menu&gt; element counter number &lt;nullable&gt; Counter to generate ContextMenuItem key names. Source: classes/ContextMenuHtml5Builder.js, line 89 Returns: Counter to generate ContextMenuItem key names. Type number fromMenu(element) Helper function to build ContextMenuItems from an html5 menu element. Parameters: Name Type Description element JQuery | string Menu element to generate the menu from. Source: classes/ContextMenuHtml5Builder.js, line 70 Returns: Collection of ContextMenuItem Type Object.&lt;string, ContextMenuItem&gt; inputLabel(node) Get the input label for the given node. Parameters: Name Type Description node HTMLElement Html element Source: classes/ContextMenuHtml5Builder.js, line 56 Returns: Input label element Type string | JQuery | jQuery × Search results Close "},"ContextMenuItem.html":{"id":"ContextMenuItem.html","title":"Interface: ContextMenuItem","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Interface: ContextMenuItem ContextMenuItem The items map contains the commands to list in the menu. Each command has a unique key identifying an item object. The value may either be an item (properties explained below), or a string (which will insert a separator, disregarding the string's content). It is also possible to define a seperator the same as an item, and use the type:cm_separator to define it. var items = { firstCommand: itemOptions, separator1: &quot;-----&quot;, separator2: { &quot;type&quot;: &quot;cm_separator&quot; }, command2: itemOptions } Since 2.3 it is also possible to use a promise as item, so you can build submenu's based on a snynchronous promis. Check out the demo using a promise for an example how to use this. The example uses jQuery deferred, but any promise should do. Promised can only be used in combination with the build option. Properties: Name Type Argument Description name string Specify the human readable name of the command in the menu. This is used as the label for the option. isHtmlName boolean Should this item be called with .html() instead of .text(). Cannot be used with the accesskey option in the same item. callback ContextMenuItemCallback Specifies the callback to execute if the item is clicked. className string Specifies additional classNames to add to the menu item. Seperate multiple classes by using spaces. icon ContextMenuIconCallback | string Specifies the icon class to set for the item. When using a string icons must be defined in CSS with selectors like .context-menu-item.context-menu-icon-edit, where edit is the icon class specified. When using a callback you can return a class string to use that as the class on the item. You can also modify the element by using the $itemElement argument. disabled ContextMenuItemCallback | boolean Specifies if the command is disabled (true) or enabled (false). May be a callback returning a boolean. visible ContextMenuItemCallback | boolean Specifies if the command is disabled (true) or enabled (false). May be a callback returning a boolean. type ContextMenuItemTypes | string Specifies the type of the command. See ContextMenuItemTypes. events Object.&lt;string, function()&gt; Events to register on a ContextMenuItem. The contents of the options object are passed as jQuery e.data. value string The value of the &lt;input&gt; element. selected boolean | string The selected option of a select element and the checked property for checkbox and radio ContextMenuItemTypes. radio string Specifies the group of the radio element. options string Specifies the options of the select element. height Number The height in pixels &lt;textarea&gt; element. If not specified, the height is defined by CSS. items Object.&lt;string, ContextMenuItem&gt; Items to show in a sub-menu. You can nest as many as you like. accesskey string Character(s) to be used as accesskey. Considering a b c $.contextMenu will first try to use »a« as the accesskey, if already taken, it'll fall through to b. Words are reduced to the first character, so hello world is treated as h w. Note: Accesskeys are treated unique throughout one menu. This means an item in a sub-menu can't occupy the same accesskey as an item in the main menu. $input JQuery &lt;nullable&gt; The input element if it was build for this item. items Object.&lt;string, ContextMenuItem&gt; Object containing the menu items. Source: classes/ContextMenuItemTypes.js, line 1 × Search results Close "},"ContextMenuOperations.html":{"id":"ContextMenuOperations.html","title":"Class: ContextMenuOperations","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Class: ContextMenuOperations ContextMenuOperations new ContextMenuOperations() Source: classes/ContextMenuOperations.js, line 9 Methods activated(e, menuData) Operation that will run after contextMenu showed on screen. Parameters: Name Type Description e JQuery.Event menuData ContextMenuData Source: classes/ContextMenuOperations.js, line 690 Returns: Type undefined create(e, currentMenuData, rootMenuData) Create a menu based on the options. Also created submenus. Parameters: Name Type Argument Description e JQuery.Event currentMenuData ContextMenuData rootMenuData ContextMenuData &lt;nullable&gt; Source: classes/ContextMenuOperations.js, line 195 hide(e, menuData, force) Hide the menu. Parameters: Name Type Description e JQuery.Event menuData ContextMenuData force boolean Source: classes/ContextMenuOperations.js, line 110 layer(e, menuData, zIndex) Create the overlay layer so we can capture the click outside the menu and close it. Parameters: Name Type Description e JQuery.Event menuData ContextMenuData zIndex number Source: classes/ContextMenuOperations.js, line 585 Returns: Type jQuery processPromises(e, currentMenuData, rootMenuData, promise) Process submenu promise. Parameters: Name Type Description e JQuery.Event currentMenuData ContextMenuData rootMenuData ContextMenuData promise Promise Source: classes/ContextMenuOperations.js, line 631 resize(e, $menu, nested) Resize the menu to its content. Parameters: Name Type Argument Description e ContextMenuEvent $menu JQuery nested boolean &lt;nullable&gt; Source: classes/ContextMenuOperations.js, line 463 show(e, menuData, x, y) Show the menu. Parameters: Name Type Description e JQuery.Event menuData ContextMenuData x number y number Source: classes/ContextMenuOperations.js, line 25 update(e, currentMenuData, rootMenuData) Update the contextmenu, re-evaluates the whole menu (including disabled/visible callbacks) Parameters: Name Type Argument Description e JQuery.Event currentMenuData ContextMenuData &lt;nullable&gt; rootMenuData ContextMenuData &lt;nullable&gt; Source: classes/ContextMenuOperations.js, line 511 × Search results Close "},"ContextMenuOptions.html":{"id":"ContextMenuOptions.html","title":"Interface: ContextMenuOptions","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery Interface: ContextMenuOptions ContextMenuOptions Register new contextMenu To register a new contextMenu: $.contextMenu( contextMenuOptions );Update contextMenu state It is possible to refresh the state of the contextmenu disabled, visibility, icons and input values through the update command. This will reevaluate any custom callbacks. $('.context-menu-one').contextMenu('update'); // update single menu $.contextMenu('update') // update all open menus Properties: Name Type Argument Default Description selector null | string Selector on which the contextMenu triggers. items Object.&lt;string, ContextMenuItem&gt; Object with items to be listed in contextMenu. See ContextMenuItem for a full documentation on how to build your menu items. appendTo JQuery.Selector | DOMElement &lt;optional&gt; document.body Specifies the selector string or DOMElement the generated menu is to be appended to. trigger 'right' | 'left' | 'hover' | 'touchstart' | 'none' left Method to trigger context menu [&quot;right&quot;, &quot;left&quot;, &quot;hover&quot;, &quot;touchstart&quot;, &quot;none&quot;]. itemClickEvent string &lt;nullable&gt; Allows the selection of the click event instead of the mouseup event to handle the user mouse interaction with the contexMenu. The default event is mouseup. Set the option to &quot;click&quot; to change to the click event. This option is global: the first contexMenu registered sets it. To change it afterwards all the contextMenu have to be unregistered with $.contextMenu( 'destroy' ); before the change has effect again. hideOnSecondTrigger boolean false Flag denoting if a second trigger should close the menu, as long as the trigger happened on one of the trigger-element's child nodes. This overrides the reposition option. selectableSubMenu boolean false Ability to select ContextMenuItem containing a submenu. reposition boolean true flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu as long as the trigger happened on one of the trigger-element's child nodes delay number 200 ms to wait before showing a hover-triggered context menu. autoHide boolean true Hide menu when mouse leaves trigger / menu elements. zIndex number | function 1 offset to add to zIndex className string Class to be appended to the root menu. classNames Object Default classname configuration to be able avoid conflicts in frameworks. Properties Name Type Default Description hover string context-menu-hover disabled string context-menu-disabled visible string context-menu-visible notSelectable string context-menu-not-selectable icon string context-menu-icon iconEdit string context-menu-icon-edit iconCut string context-menu-icon-cut iconCopy string context-menu-icon-copy iconPaste string context-menu-icon-paste iconDelete string context-menu-icon-delete iconAdd string context-menu-icon-add iconQuit string context-menu-icon-quit iconLoadingClass string context-menu-icon-loading animation Object Animation settings Properties Name Type Default Description duration number 50 show string 'slideDown' hide string 'slideUp' events Object Event callbacks. This is the trigger element, first argument is the event, and the second argumant ContextMenuData. Properties Name Type Description show function Called when contextmenu is shown. hide function Called when contextmenu is hidden. activated function Called when contextmenu is activated. callback ContextMenuItemCallback Global callback called then a ContextMenuItem is clicked. build ContextMenuBuildCallback false position position Callback to override the position of the context menu. The function is executed in the context of the trigger object. The first argument is a jQuery.Event. The second argument is the ContextMenuData object, which has a $menu property with the menu that needs to be positioned. The third and fourth arguments are x and y coordinates provided by the show event. The x and y may either be integers denoting the offset from the top left corner, undefined, or the string &quot;maintain&quot;. If the string &quot;maintain&quot; is provided, the current position of the $menu must be used. If the coordinates are undefined, appropriate coordinates must be determined. An example of how this can be achieved is provided with determinePosition. determinePosition determinePosition positionSubmenu positionSubmenu Callback tha positions a submenu _hasContext boolean Set to true if the call was done from an element. Source: defaults/index.js, line 27 Methods determinePosition($menu) Determine the position for a root menu. Parameters: Name Type Description $menu JQuery Source: defaults/position.js, line 1 position(e, currentMenuData, x, y) Position the root menu. Parameters: Name Type Description e JQuery.Event currentMenuData ContextMenuData x number | string y number | string Source: defaults/position.js, line 28 positionSubmenu(e, $menu) Position a submenu. Parameters: Name Type Description e JQuery.Event $menu JQuery Source: defaults/position.js, line 78 × Search results Close "},"external-_jQuery.fn_.html":{"id":"external-_jQuery.fn_.html","title":"External: jQuery.fn","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery External: jQuery.fn jQuery.fn The jQuery plugin namespace. Source: jquery/contextMenuFunction.js, line 1 See: The jQuery Plugin Guide × Search results Close "},"external-_jQuery_.html":{"id":"external-_jQuery_.html","title":"External: jQuery","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery External: jQuery jQuery The jQuery namespace. Source: contextmenu.js, line 6 See: The jQuery Plugin Guide × Search results Close "},"tutorial-custom-command-types.html":{"id":"tutorial-custom-command-types.html","title":"Tutorial: custom-command-types","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery custom-command-types Custom Command Types Besides the built-in command types custom handlers can be defined. The command generator must be placed in $.contextMenu.types. It is identified by the key given in that object. The generator function is executed in the context of the new command's &lt;li&gt; within the menu. item is the object passed at creation. Use this to pass values from your definition to the generator. contextMenuData is the current menu level, rootMenuData is the menu's rootMenuData-level contextMenuData (relevant for sub-menus only). A custom command type can be whatever you like it to be, it can behave how ever you want it to behave. Besides the keyboard interaction paradigm (up, down, tab, escape) key-events are passed on to the &lt;li&gt; which can be accessed via $(this).on('keydown', …); Note that you'll probably want to disable default action handling (click, pressing enter) in favor of the custom command's behavior. $.contextMenu.types.myType = function(item, contextMenuData, rootMenuData) { $('&lt;span&gt;' + item.customName + '&lt;/span&gt;').appendTo(this); this.on('contextmenu:focus', function(e) { // setup some awesome stuff }).on('contextmenu:blur', function(e) { // tear down whatever you did }).on('keydown', function(e) { // some funky key handling, maybe? }); }; $.contextMenu({ selector: '.context-menu-custom', items: { label: {type: &quot;myType&quot;, customName: &quot;Foo Bar&quot;} } }); × Search results Close "},"tutorial-customize.html":{"id":"tutorial-customize.html","title":"Tutorial: customize","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery customize Customize iconsYou can add icons to src/icons and run gulp build-icons. This will make the icons available for use in the contextmenu using the icon property. So for example the file checkmark.svg wil result in the CSS context-menu-icon-checkmark which you can use by using the icon option when defining a menu item. Is is also possible to just use FontAwesome icons, see the demo of FontAwesome. Examplevar items = { firstCommand: { name: &quot;Paste&quot;, icon: &quot;checkmark&quot; // Class context-menu-icon-checkmark is used on the menu item. This is generated from checkmark.svg } }Font-Awesome icons used from encharm/Font-Awesome-SVG-PNG. You can download more there if you like. Finally, you will need to re-build the CSS using sass, otherwise you may see mismatchings between the icon references. Use the command gulp css to re-build the CSS in the dist directory. The new CSS files will contain the icons you added. Customize CSSYou can use the _variables.scss to adjust variables on pretty much everything you want to change. × Search results Close "},"tutorial-events.html":{"id":"tutorial-events.html","title":"Tutorial: events","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery events Events contextmenu prevcommand nextcommand contextmenu:hide contextmenu:focus contextmenu:blur keydown List of events that are triggered on the menu. You can manually trigger some events to control the menu. contextmenucontextmenu : Trigger context menu to be shown for a trigger object. Available on trigger object. The Event must be supplied with coordinates for the menu: {pageX: 123, pageY:123} $('.context-menu-one').first().trigger( $.Event('contextmenu', {pageX: 123, pageY: 123}) ); $('.context-menu-one').first().trigger(&quot;contextmenu&quot;);will invoke determinePosition to position the menu. prevcommandprevcommand : Select / highlight the previous possible command Available on context menu. currentMenuData.$menu.trigger(&quot;prevcommand&quot;);nextcommandnextcommand : Select / highlight the next possible command Available on context menu. currentMenuData.$menu.trigger(&quot;nextcommand&quot;);contextmenu:hidecontextmenu:hide : Hide the menu Available on context menu. currentMenuData.$menu.trigger(&quot;contextmenu:hide&quot;);contextmenu:focuscontextmenu:focus : React to a command item being focused Triggered on context menu item when mouse or keyboard interaction lead to a &quot;hover state&quot; for that command item. $(document.body).on(&quot;contextmenu:focus&quot;, &quot;.context-menu-item&quot;, function(e){ console.log(&quot;focus:&quot;, this); } );contextmenu:blurcontextmenu:blur : Available on each context menu item. Triggered on context menu item when mouse or keyboard interaction lead from a &quot;hover state&quot; to &quot;default state&quot; for that command item. $(document.body).on(&quot;contextmenu:blur&quot;, &quot;.context-menu-item&quot;, function(e){ console.log(&quot;blur:&quot;, this); } );keydownkeydown : Available on each context menu item. Triggered on context menu item when keyboard interaction could not be handled by jQuery.contextMenu. $(document.body).on(&quot;keydown&quot;, &quot;.context-menu-item&quot;, function(e){ console.log(&quot;key:&quot;, e.keyCode); } ); × Search results Close "},"tutorial-font-awesome.html":{"id":"tutorial-font-awesome.html","title":"Tutorial: font-awesome","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery font-awesome Customize iconsIt is possible to use font-awesome icons if you like. You need to include the Font Awesome CSS in your application. That will enable you to use the icon classes to use those icons. Check out the demo Bring your own iconsIt is also possible to use your own SVG icons if you like, you can customize this by using the SASS files. × Search results Close "},"tutorial-html5-polyfill.html":{"id":"tutorial-html5-polyfill.html","title":"Tutorial: html5-polyfill","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery html5-polyfill HTML5 &lt;menu&gt; shiv/polyfill HTML5 &lt;menu&gt; import HTML5 &lt;menu&gt; shiv/polyfill HTML5 &lt;menu&gt; importconsidering the following HTML $.contextMenu.fromMenu($('#html5menu')) will return a proper items object. &lt;menu id=&quot;html5menu&quot; type=&quot;context&quot; style=&quot;display:none&quot;&gt; &lt;command label=&quot;rotate&quot; onclick=&quot;alert('rotate')&quot;&gt; &lt;command label=&quot;resize&quot; onclick=&quot;alert('resize')&quot;&gt; &lt;menu label=&quot;share&quot;&gt; &lt;command label=&quot;twitter&quot; onclick=&quot;alert('twitter')&quot;&gt; &lt;hr&gt; &lt;command label=&quot;facebook&quot; onclick=&quot;alert('facebook')&quot;&gt; &lt;/menu&gt; &lt;/menu&gt;$.contextMenu.fromMenu() will properly import (and thus handle) the following elements. Everything else is imported as {type: &quot;html&quot;} &lt;menu&gt; &lt;hr&gt; &lt;a&gt; &lt;command type=&quot;command|radio|checkbox&quot;&gt; (W3C Specification) &lt;menuitem type=&quot;command|radio|checkbox&quot;&gt; (Firefox) &lt;input type=&quot;text|radio|checkbox&quot;&gt; &lt;select&gt; &lt;textarea&gt; &lt;label for=&quot;someId&quot;&gt; &lt;label&gt; the text &lt;input|textarea|select&gt;The &lt;menu&gt; must be hidden but not removed, as all command events (clicks) are passed-thru to the original command element! Note: While the specs note &lt;option&gt;s to be renderd as regular commands, $.contextMenu will render an actual &lt;select&gt;. HTML5 &lt;menu&gt; shiv/polyfillEngaging the HTML5 polyfill (ignoring $.contextMenu if context menus are available natively): $(function(){ $.contextMenu(&quot;html5&quot;); });Engaging the HTML5 polyfill (ignoring browser native implementation): $(function(){ $.contextMenu(&quot;html5&quot;, true); }); × Search results Close "},"tutorial-input-helpers.html":{"id":"tutorial-input-helpers.html","title":"Tutorial: input-helpers","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery input-helpers Helpers Import values for &lt;input&gt; Export values from &lt;input&gt; Import values for &lt;input&gt;To fill input commands with values from a map: {events: { hide: function(e, currentMenuData){ $.contextMenu.getInputValues(currentMenuData, {command1: &quot;foo&quot;, command2: &quot;bar&quot;}); } } }To fill input commands with values from data-attributes: {events: { hide: function(e, currentMenuData){ $.contextMenu.getInputValues(currentMenuData, this.data()); } } }Export values from &lt;input&gt;To fetch values from input commands: {events: { hide: function(e, currentMenuData){ var values = $.contextMenu.setInputValues(currentMenuData} } }To save values from input commands to data-attributes: {events: { hide: function(e, currentMenuData){ $.contextMenu.setInputValues(currentMenuData, this.data()); } } } × Search results Close "},"tutorial-plugin-commands.html":{"id":"tutorial-plugin-commands.html","title":"Tutorial: plugin-commands","body":" jQuery contextMenu reference Classes ContextMenuContextMenuEventHandlerContextMenuHtml5BuilderContextMenuOperations Interfaces ContextMenuDataContextMenuItemContextMenuOptions Tutorials custom-command-typescustomizeeventsfont-awesomehtml5-polyfillinput-helpersplugin-commands Global buildOptionsContextMenuItemTypescreatedestroyhtml5normalizeArgumentssplitAccesskeyupdatezindex Externals jQuery.fnjQuery plugin-commands currentMenu: plugin-commandsPlugin commands Disable a contextMenu trigger Enable a contextMenu trigger Manually show a contextMenu Manually hide a contextMenu Unregister all contextMenus Disable a contextMenu triggerdisable contextMenu to be shown on specified trigger elements $(&quot;.some-selector&quot;).contextMenu(false);Enable a contextMenu triggerenable contextMenu to be shown on specified trigger elements $(&quot;.some-selector&quot;).contextMenu(true);Manually show a contextMenushow the contextMenu of the first element of the selector (position determined by determinePosition): $(&quot;.some-selector&quot;).contextMenu(); $(&quot;.some-selector&quot;).contextMenu({x: 123, y: 123});Manually hide a contextMenuhide the contextMenu of the first element of the selector: $(&quot;.some-selector&quot;).contextMenu(&quot;hide&quot;); Unregister contextMenuUnregister a specific contextMenuTo unregister / destroy a specific contextMenu: $.contextMenu( 'destroy', selector );selector expects the (string) selector that the contextMenu was registered to Unregister all contextMenusTo unregister / destroy all contextMenus: $.contextMenu( 'destroy' ); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
